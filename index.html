<!doctype html>
<html lang="ru" data-lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Анатомия товара</title>
  <meta name="description" content="Анатомия товара — интерактивный скан товара по 1–3 фото. Локально в браузере." />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Noto+Sans+SC:wght@400;500;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#ffffff;
      --surface:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --line:rgba(2,6,23,.10);

      --accent:#7c5cff;
      --accent2:#5b38ff;
      --accentSoft:rgba(124,92,255,.14);

      --good:#16a34a;
      --warn:#f59e0b;
      --bad:#ef4444;

      --shadow: 0 14px 34px rgba(2,6,23,.10);
      --shadowSoft: 0 10px 22px rgba(2,6,23,.08);
      --radius:18px;
      --btnH: 44px;
      --btnW: 148px; /* компактно, но влезает почти всё */
      /* spacing */
      --space-2:12px;
      --space-3:16px;
      --space-4:20px;

      /* typography */
      --sans: "Inter","Noto Sans SC",system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans",sans-serif;
      --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;

      --fs-title: 22px;
      --fs-section: 18px;
      --fs-label: 13px;
      --fs-body: 14px;
      --fs-small: 12px;

      --lh-tight: 1.15;
      --lh-body: 1.55;
      --ls-tight: -0.02em;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: var(--bg);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      font-size: var(--fs-body);
      line-height: var(--lh-body);
      -webkit-tap-highlight-color: transparent;
      font-optical-sizing: auto;
    }

    /* Top bar */
    .top{
      position:sticky; top:0; z-index:50;
      background: rgba(255,255,255,.92);
      border-bottom:1px solid rgba(2,6,23,.08);
    }
    @supports (backdrop-filter: blur(10px)) {
      .top{ backdrop-filter:saturate(160%) blur(10px); background: rgba(255,255,255,.78); }
    }
    .topbar{
      max-width:1100px;
      margin:0 auto;
      padding: var(--space-3) var(--space-3);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--space-3);
    }
    .brand{ display:flex; align-items:center; gap:var(--space-2); min-width:0; }
    .dot{ width:10px; height:10px; border-radius:999px; background: var(--accent2); box-shadow: 0 0 0 6px rgba(124,92,255,.14); flex:0 0 auto; }
    .brandText{ min-width:0; }
    .brandTitle{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 800; letter-spacing: var(--ls-tight); }
    .brandSub{ font-size: var(--fs-small); line-height: 1.25; color: var(--muted); margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .topRight{ display:flex; align-items:center; gap:var(--space-2); flex:0 0 auto; }

    /* headings */
    .hTitle{ font-weight: 800; letter-spacing: var(--ls-tight); font-size: var(--fs-title); line-height: var(--lh-tight); margin: 0; }
    .hSection{ font-weight: 700; letter-spacing: var(--ls-tight); font-size: var(--fs-section); line-height: var(--lh-tight); margin: 0; }
    .hLabel, .label{ font-size: var(--fs-label); font-weight: 700; color: rgba(2,6,23,.78); margin: 0; }
    .p{ margin: 0; color: var(--muted); font-size: var(--fs-body); line-height: var(--lh-body); }
    .meta{ font-size: var(--fs-small); color: rgba(2,6,23,.68); line-height: 1.35; }
    .metaStrong{ font-weight: 900; }
    .mono{ font-family: var(--mono); }

    /* spacers */
    .sp-2{ height: var(--space-2); }
    .sp-3{ height: var(--space-3); }
    .sp-4{ height: var(--space-4); }

    /* layout helpers */
    /* RESULT header alignment */
    .resultTop{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: var(--space-3);
      flex-wrap:wrap;
    }
    .resultHead{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: var(--space-3);
      align-items:start;
    }
    .resultMeta{
      display:grid;
      gap: 10px;
      min-width: 0;
    }
    .resultScore{
      display:flex;
      align-items:flex-start;
      justify-content:flex-end;
    }
    @media (max-width:560px){
      .resultHead{ grid-template-columns: 1fr; }
      .resultScore{ justify-content:flex-start; }
    }

    /* miniExplain — компактная строка (без списка) */
    /* RESULT: align text start with badge text (badge has padding = --space-2) */
    #viewResult .resultMeta{
      padding-left: var(--space-2); /* 12px: теперь текст совпадает с началом текста в badge */
    }

    /* убираем повтор (большой заголовок "НЕ СЕГОДНЯ") — результат уже в badge */
    #viewResult #levelTitle{ display:none; }

    /* одна строка: подтекст + детализация */
    #viewResult .resultLine{
      display:block;
      line-height: 1.35;
    }

    /* компактно: детализация в одну строку через • */
    #miniExplain{
      display:inline;
      margin-left: 8px;
      white-space: normal;
    }
    #miniExplain span{
      display:inline;
    }
    #miniExplain span::before{
      content:""; /* убрали буллеты */
    }
    #miniExplain span:not(:last-child)::after{
      content:" • ";
      color: rgba(2,6,23,.45);
      font-weight: 900;
    }
    .row{ display:flex; gap: var(--space-2); }
    .row3{ display:flex; gap: var(--space-3); }
    .between{ justify-content:space-between; }
    .center{ align-items:center; }
    .wrapFlex{ flex-wrap:wrap; }
    .flex1{ flex:1; }
    .minw220{ min-width:220px; }
    .pctAccent{ color: rgba(124,92,255,.95); font-weight: 900; }

    .pill{
      font-family:var(--mono);
      font-size: 12px;
      font-weight: 800;
      padding: var(--space-2);
      border-radius: 999px;
      border:1px solid rgba(2,6,23,.10);
      background: rgba(255,255,255,.92);
      color: rgba(2,6,23,.72);
      white-space: nowrap;
    }
    .lang{ display:flex; gap:var(--space-2); align-items:center; }
    .langLink{
      text-decoration:none;
      font-family:var(--mono);
      font-size:12px;
      padding: var(--space-2);
      border-radius:999px;
      border:1px solid rgba(2,6,23,.10);
      background: rgba(255,255,255,.92);
      color: rgba(2,6,23,.72);
      font-weight: 800;
      transition: transform .12s ease, box-shadow .18s ease, background .18s ease;
      white-space: nowrap;
      touch-action: manipulation;
    }
    .langLink:hover{ transform:translateY(-1px); box-shadow: var(--shadowSoft); }
    .langLink:focus-visible{ outline:3px solid rgba(124,92,255,.25); outline-offset:2px; }
    .langLink.active{ background: rgba(124,92,255,.14); border-color: rgba(124,92,255,.30); color: rgba(20,10,43,.95); }

    .wrap{ max-width:1100px; margin:0 auto; padding: var(--space-4) var(--space-3); }
    .grid{ display:grid; grid-template-columns: minmax(340px, 440px) 1fr; gap: var(--space-4); align-items:start; }
    @media (max-width: 980px){
      .grid{ grid-template-columns:1fr; }
      .wrap{ padding: var(--space-3); }
      .topbar{ padding: var(--space-3); }
    }
    /* FIX: чтобы гриды/флексы не раздували колонку и не "глотали" текст */
    .grid > section,
    .card,
    .phone,
    .pad,
    .drop,
    .field,
    .resultMeta {
      min-width: 0;
    }

    .p, .meta, .desc, .liTextStrong {
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    /* FIX: btnline НЕ должен быть nowrap — иначе 3 кнопки ломают левую колонку */

    .card, .phone{ background: var(--surface); border:1px solid rgba(2,6,23,.10); border-radius: var(--radius); box-shadow: var(--shadow); overflow:hidden; }
    .pad{ padding: var(--space-4); display:grid; gap: var(--space-3); }

    /* Right side spacing FIX: views are grids with uniform gaps */
    .view{ display:grid; gap: var(--space-3); }
    .view[hidden]{ display:none !important; }

    /* each panel is its own block */
    .panel{
      border:1px solid rgba(2,6,23,.10);
      border-radius: var(--radius);
      background: rgba(255,255,255,.98);
      padding: var(--space-4);
      display:grid;
      gap: var(--space-3);
      transition: none;
    }

    
    .divider{ height:1px; background: rgba(2,6,23,.10); opacity:.35; }

    .field{ display:grid; gap: var(--space-2); }
    select{
      width:100%;
      padding: var(--space-2) var(--space-3);
      border-radius: 16px;
      border:1px solid rgba(2,6,23,.12);
      background:#fff;
      outline:none;
      font-weight: 650;
      font-family: var(--sans);
      touch-action: manipulation;
    }
    select:focus-visible{ outline:3px solid rgba(124,92,255,.20); outline-offset:2px; }

    .btnrow{
      display:flex;
      gap: var(--space-2);
      flex-wrap:wrap;
      align-items:center;
    }
    .btnrow.btncol{
      flex-direction: column;
      align-items: flex-start;
    }
    /* Кнопки в одну строку (2 или 3 штуки) и одного размера */
    .btnrow.btnline{
      flex-wrap: nowrap;
      justify-content: flex-start;
    }

    /* одинаковая ширина внутри строки + не слишком длинные */
    .btnrow.btnline .btn{
      flex: 1 1 0;
      min-width: 132px;
      max-width: 190px;   /* ограничиваем “длину” */
    }

    /* на узких экранах разрешаем перенос, чтобы не ломалось */
    @media (max-width: 420px){
      .btnrow.btnline{ flex-wrap: wrap; }
      .btnrow.btnline .btn{ max-width: none; }
    }


    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: var(--space-2);

      height: var(--btnH);
      min-height: var(--btnH);
      width: var(--btnW);
      min-width: var(--btnW);
      max-width: var(--btnW);

      padding: 0 14px;
      border-radius: 999px;
      border:1px solid rgba(2,6,23,.12);
      background: rgba(255,255,255,.96);
      color: var(--text);
      cursor:pointer;
      font-weight: 800;

      /* чтобы текст не делал кнопку выше */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      /* плоско */
      box-shadow: none;
      transform: none;

      /* без подъёма */
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }

    .btn:hover{ transform:none; box-shadow:none; }
    .btn:active{ transform:none; box-shadow:none; }
    .btn:disabled{ opacity:.45; cursor:not-allowed; box-shadow:none; }
    .btn:focus-visible{ outline:3px solid rgba(124,92,255,.22); outline-offset:2px; }

    .btnPrimary{
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border-color: rgba(124,92,255,.35);
      color:#fff;
      box-shadow: none;
    }
    .btnPrimary:hover{ box-shadow: none; }
    .btnGhost{ background: rgba(255,255,255,.70); }
    .btnSmall{
      height: var(--btnH);
      min-height: var(--btnH);
      width: var(--btnW);
      min-width: var(--btnW);
      max-width: var(--btnW);
      padding: 0 14px;
      font-size: 13px;
    }
    .uploader{ border-radius: var(--radius); padding: 0; border: 0 dashed rgba(124,92,255,.45); background: rgba(124,92,255,.06); }
    input[type="file"]{ position:absolute; left:-9999px; width:1px; height:1px; opacity:0; }
    .drop{ border-radius: var(--radius); background: rgba(255,255,255,.98); border:1px solid rgba(2,6,23,.06); padding: var(--space-4); display:grid; gap: var(--space-3); }

    .thumbs{ display:grid; grid-template-columns: repeat(3, 1fr); gap: var(--space-2); }
    .thumb{
      aspect-ratio: 3 / 4;
      border-radius: 16px;
      border:1px solid rgba(2,6,23,.12);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(2,6,23,.04), rgba(2,6,23,.00));
      position:relative;
      touch-action: manipulation;
    }
    .thumb img{ width:100%; height:100%; object-fit:cover; display:block; }
    .thumb .x{
      position:absolute;
      top: var(--space-2);
      right: var(--space-2);
      width:28px;
      height:28px;
      border-radius:999px;
      display:grid;
      place-items:center;
      background: rgba(255,255,255,.96);
      border:1px solid rgba(2,6,23,.12);
      cursor:pointer;
      font-weight: 900;
      line-height: 1;
      box-shadow: var(--shadowSoft);
      touch-action: manipulation;
    }
    #viewResult .minw220{
    display:grid;
    gap: 10px;
  }

    .kpi{ display:grid; grid-template-columns: 1fr 2fr; gap: var(--space-2); }
    @media (max-width:560px){ .kpi{ grid-template-columns:1fr; } }
    .kpiItem{
      border:1px solid rgba(2,6,23,.10);
      border-radius: var(--radius);
      padding: var(--space-3);
      background: rgba(255,255,255,.98);
      display:grid;
      gap: var(--space-2);
    }
    .kpiNum{ font-family: var(--mono); font-weight: 900; font-size: 18px; }
    .kpiLbl{ font-size: var(--fs-small); color: var(--muted); }
    .kpiWide{ display:grid; gap: var(--space-2); }
    .kpiHead{ display:flex; justify-content:space-between; gap: var(--space-2); align-items:center; }

    .kpiScale{ position:relative; height:18px; }
    .kpiTrack{ position:absolute; inset:0; border-radius:999px; background: rgba(2,6,23,.06); border:1px solid rgba(2,6,23,.08); }
    .kpiTicks{ position:absolute; inset:0; display:flex; justify-content:space-between; align-items:center; padding: 0 var(--space-2); }
    .kpiTicks span{ width:6px; height:6px; border-radius:999px; background: rgba(2,6,23,.12); }
    .kpiMarker{
      position:absolute;
      top:50%;
      left:0%;
      transform: translate(-50%,-50%);
      width:16px;
      height:16px;
      border-radius:999px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border:2px solid rgba(255,255,255,.96);
      box-shadow: 0 10px 20px rgba(124,92,255,.22);
      opacity:0;
      transition: left .22s ease, opacity .2s ease;
    }
    .kpiMarker.on{ opacity:1; }
    .kpiEnds{ display:flex; justify-content:space-between; font-size: var(--fs-small); color: var(--muted); margin-top:-2px; }

    .phoneTop{
      padding: var(--space-3) var(--space-4);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--space-3);
      border-bottom:1px solid rgba(2,6,23,.08);
      background: rgba(255,255,255,.96);
    }
    .phoneMeta{ font-family: var(--mono); font-size: 12px; color: rgba(2,6,23,.70); }
    .phoneMetaRight{ font-family: var(--mono); font-size: 12px; color: rgba(2,6,23,.55); }

    .screen{
      position:relative;
      padding: var(--space-4);
      display:flex;
      flex-direction:column;
      gap: var(--space-3);
      min-height: 560px;
    }
    @media (max-width:980px){ .screen{ min-height: calc(100svh - 170px); } }

    .heroImg{
      border-radius: var(--radius);
      border:1px solid rgba(2,6,23,.10);
      overflow:hidden;
      background: rgba(124,92,255,.06);
      aspect-ratio: 16 / 10;
      position:relative;
      cursor:pointer;
      touch-action: manipulation;
    }
    .heroImg img{ width:100%; height:100%; object-fit:cover; display:block; }
    .heroOverlay{
      position:absolute;
      inset:0;
      background: linear-gradient(180deg, rgba(2,6,23,.0), rgba(2,6,23,.28));
      display:flex;
      align-items:flex-end;
      padding: var(--space-3);
      color:#fff;
      font-weight: 800;
      letter-spacing: -0.01em;
      pointer-events:none;
    }

    .scanOverlay{ position:absolute; inset:0; pointer-events:none; opacity:0; transition:.2s ease; }
    .scanOverlay.on{ opacity:1; }
    .scanLine{
      position:absolute;
      left:0; right:0;
      height:2px;
      top:-2px;
      background: rgba(124,92,255,.95);
      box-shadow: 0 0 12px rgba(124,92,255,.35), 0 0 55px rgba(124,92,255,.16);
      animation: scanDown 2.1s linear infinite;
    }
    @keyframes scanDown{ 0%{top:-2px} 100%{top:100%} }

    .progressWrap{
      border:1px solid rgba(2,6,23,.10);
      border-radius: var(--radius);
      padding: var(--space-3);
      background: rgba(255,255,255,.98);
      display:grid;
      gap: var(--space-2);
    }
    .bar{ height:10px; border-radius:999px; background: rgba(2,6,23,.08); overflow:hidden; }
    .bar > div{ height:100%; width:0%; background: linear-gradient(135deg, var(--accent), var(--accent2)); transition: width .22s ease; }

    .stepList{ display:grid; gap: var(--space-2); }
    .step{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--space-2);
      border:1px solid rgba(2,6,23,.10);
      border-radius: var(--radius);
      padding: var(--space-3);
      background: rgba(255,255,255,.98);
    }
    .stepLeft{ display:flex; gap: var(--space-2); align-items:center; min-width:0; }
    .chip{
      font-family: var(--mono);
      font-size: 12px;
      padding: var(--space-2);
      border-radius: 999px;
      border:1px solid rgba(124,92,255,.28);
      background: rgba(124,92,255,.10);
      color: rgba(20,10,43,.95);
      font-weight: 900;
      white-space: nowrap;
    }
    .step{ align-items:flex-start; }
    .stepLeft{ flex:1; min-width:0; }
    .chip{
      flex:0 0 160px;   /* одинаковая ширина */
      text-align:left;
    }
    .desc{ flex:1; min-width:0; }

    @media (max-width:560px){
      .chip{ flex-basis: 128px; }
    }
    .desc{ color: var(--muted); font-size: 13px; line-height: 1.35; }
    .tick{
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border:1px solid rgba(2,6,23,.14);
      background: rgba(2,6,23,.03);
      position: relative;
      flex:0 0 auto;
    }
    .tick.on{ border-color: rgba(22,163,74,.35); background: rgba(22,163,74,.12); }
    .tick.on::after{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      width:10px;
      height:6px;
      border-left:3px solid rgba(22,163,74,.95);
      border-bottom:3px solid rgba(22,163,74,.95);
      transform: translate(-50%,-55%) rotate(-45deg);
    }

    .badge{
      font-family: var(--mono);
      font-weight: 900;
      font-size: 12px;
      padding: var(--space-2);
      border-radius: 999px;
      border:1px solid rgba(2,6,23,.10);
      background: rgba(2,6,23,.03);
      display:inline-flex;
      align-items:center;
      gap: var(--space-2);
      width: fit-content;
    }
    .badge.good{ border-color:rgba(22,163,74,.25); background:rgba(22,163,74,.10); color:rgba(22,163,74,.95); }
    .badge.warn{ border-color:rgba(245,158,11,.25); background:rgba(245,158,11,.10); color:rgba(180,83,9,.95); }
    .badge.bad{  border-color:rgba(239,68,68,.25); background:rgba(239,68,68,.10); color:rgba(185,28,28,.95); }

    .twoCol{ display:grid; grid-template-columns:1fr 1fr; gap: var(--space-3); }
    @media (max-width:560px){ .twoCol{ grid-template-columns:1fr; } }

    .li{
      display:flex;
      gap: var(--space-2);
      align-items:flex-start;
      padding: var(--space-2) 0;
      border-top:1px dashed rgba(2,6,23,.12);
    }
    .li:first-child{ border-top:none; padding-top:0; }
    .ico{
      width:22px;
      height:22px;
      border-radius:10px;
      background: rgba(124,92,255,.10);
      border:1px solid rgba(124,92,255,.20);
      flex:0 0 auto;
      margin-top: 1px;
    }
    .liTextStrong{ font-weight: 800; }

    .panelInner{ padding: var(--space-3); box-shadow:none; }

    /* List containers on the right: add uniform gaps */
    #obsList, #flagsList, #sellerMsgs { display:grid; gap: var(--space-2); }

    .msgBlock{ padding: var(--space-2) 0; border-top:1px dashed rgba(2,6,23,.12); }
    .msgBlock:first-child{ border-top:none; padding-top:0; }
    .msgTitle{ font-weight:900; }

    .footerNote{ border-top:1px solid rgba(2,6,23,.08); padding-top: var(--space-2); color: var(--muted); font-size: var(--fs-small); line-height: 1.45; }

    .mobileActions{
      display:none;
      position:sticky;
      bottom: var(--space-2);
      z-index:10;
      gap: var(--space-2);
      padding: var(--space-2);
      border-radius: var(--radius);
      border:1px solid rgba(2,6,23,.10);
      background: rgba(255,255,255,.92);
      box-shadow: var(--shadow);
    }
    @media (max-width:980px){ .mobileActions{ display:flex; } }

    .toast{
      position:fixed;
      left:50%;
      bottom: var(--space-3);
      transform:translateX(-50%);
      background: rgba(2,6,23,.92);
      color:#fff;
      padding: var(--space-2);
      border-radius: 14px;
      font-weight: 800;
      font-size: 13px;
      box-shadow: 0 12px 30px rgba(0,0,0,.18);
      z-index: 9999;
      opacity: 0;
      transition: opacity .15s ease;
      max-width: min(92vw, 560px);
    }
    .toast.on{ opacity:1; }

    .srOnly{
      position:absolute !important;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
  </style>
</head>

<body>
  <div class="top">
    <div class="topbar">
      <div class="brand">
        <div class="dot"></div>
        <div class="brandText">
          <div class="brandTitle">Анатомия товара</div>
          <div class="brandSub" id="brandSub">Интерактивный скан</div>
        </div>
      </div>

      <div class="topRight">
        <div class="pill" id="stagePill">ЭТАП: ЗАГРУЗКА</div>
        <nav class="lang" aria-label="Language">
          <a class="langLink active" href="./casual-anatomy-ru.html">RU</a>
          <a class="langLink" href="./casual-anatomy-en.html">EN</a>
          <a class="langLink" href="./casual-anatomy-zh.html">中文</a>
        </nav>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="grid">
      <section class="card">
        <div class="pad">
          <div class="hTitle" id="leftTitle">Проверка товара до покупки</div>
          <p class="p" id="leftIntro">
            Выбери категорию, загрузи <b>1–3 фото</b> и за 10 секунд получишь разбор.
            Это не ИИ и не гарантия качества. Это оценка риска по тому, что реально видно на фото.
          </p>

          <div class="field">
            <div class="hLabel" id="catLabel">Категория товара</div>
            <select id="categorySelect" aria-label="Категория товара">
              <option value="universal">Любые товары</option>
              <option value="clothing">Одежда</option>
              <option value="leather">Кожа/Замша</option>
              <option value="bag">Сумки/Аксессуары</option>
              <option value="shoes">Обувь</option>
            </select>
            <div class="meta" id="categoryHint"></div>
          </div>

          <div class="uploader">
            <div class="drop" id="dropZone">
              <div class="btnrow btncol">
                <button class="btn btnPrimary" id="btnPick" type="button">Добавить фото</button>
                <button class="btn btnGhost" id="btnDemo" type="button">Демо</button>
              </div>

              <div class="meta" id="limitText">
                Лимит: <b>1–3</b> фото. Поддержка HEIC зависит от браузера:
                если не открывается, то сохрани как JPG или PNG.
              </div>

              <input id="fileInput" type="file" accept="image/*" multiple />

              <div class="thumbs" id="thumbs" aria-label="Превью фотографий"></div>

              <div class="divider"></div>
              <div class="btnrow btnline">
                <button class="btn btnPrimary" id="btnStart" type="button" disabled>Запустить скан</button>
                <button class="btn" id="btnClear" type="button" disabled>Очистить</button>
                <button class="btn" id="btnCopyLink" type="button">Скопировать ссылку</button>
              </div>


              <div class="meta" id="hintText">
                Если продавец не показывает ткань, швы и фурнитуру — это уже риск.
                Скан подскажет, что спросить.
              </div>
            </div>
          </div>

          <div class="kpi" aria-label="Сводка">
            <div class="kpiItem">
              <div class="kpiNum" id="kpiPhotos">0</div>
              <div class="kpiLbl" id="kpiPhotosLbl">Фото</div>
            </div>

            <div class="kpiItem kpiWide">
              <div class="kpiHead">
                <span id="kpiRatingLbl">Рейтинг</span>
                <span class="mono" id="kpiRating">—</span>
              </div>

              <div class="kpiScale" id="kpiScale" aria-label="Шкала оценки">
                <div class="kpiTrack"></div>
                <div class="kpiTicks" aria-hidden="true">
                  <span></span><span></span><span></span><span></span><span></span>
                </div>
                <div class="kpiMarker" id="kpiMarker" aria-hidden="true"></div>
              </div>

              <div class="kpiEnds">
                <span id="kpiLeftEnd">не сегодня</span>
                <span id="kpiRightEnd">вау</span>
              </div>
            </div>
          </div>

          <div class="panel" id="privacyPanel">
            <div class="mono meta metaStrong" id="privacyTitle">Политика конфиденциальности</div>
            <div class="meta" id="privacyText">
              • Фото обрабатываются <b>локально</b> в браузере: сайт ничего не загружает на сервер.<br>
              • Не загружай персональные данные (лица, документы, адреса, платежные коды).<br>
              • Результат — рекомендация. Не экспертиза, не подтверждение качества и не гарантия.<br>
              • Загружая фото, ты подтверждаешь право их использовать (свои фото/скриншоты или с разрешения).<br>
              • Права на концепт, дизайн и тексты: <b>© rara_illustra</b>.
            </div>
          </div>
        </div>
      </section>

      <section class="phone">
        <div class="phoneTop">
          <div class="phoneMeta">Анатомия товара • <span id="phoneMode">Готово</span></div>
          <div class="phoneMetaRight"><span id="timer">0:00</span> / 0:10</div>
        </div>

        <div class="screen" id="screen">
          <div class="scanOverlay" id="scanOverlay"><div class="scanLine"></div></div>

          <div id="viewReady" class="view">
            <div class="heroImg" id="heroImg" role="button" aria-label="Выбрать фото">
              <div class="heroOverlay" id="heroOverlay">Загрузи 1–3 фото и нажми НАЧАТЬ.</div>
            </div>

            <div class="panel">
              <div class="badge" id="readyBadge">Профиль: Любые товары</div>
              <div class="hSection" id="readyTitle">Проверка по фото за 10 секунд</div>
              <div class="meta" id="readySubtitle"></div>

              <div class="btnrow">
                <button class="btn btnPrimary" id="btnStart2" type="button" disabled>НАЧАТЬ</button>
                <button class="btn" id="btnShare" type="button">Поделиться</button>
              </div>
            </div>

            <div class="footerNote" id="readyFooter">
              Не нужно ссылок: просто загрузи скрин карточки товара с маркетплейса.
            </div>
          </div>

          <div id="viewScan" class="view" hidden>
            <div class="progressWrap">
              <div class="mono meta kpiHead">
                <span id="scanTitle">Скан</span>
                <span id="pct" class="pctAccent">0%</span>
              </div>
              <div class="bar"><div id="barFill"></div></div>
              <div class="meta" id="scanTip">Подготовка…</div>
            </div>

            <div class="stepList" id="steps"></div>

            <div class="footerNote" id="decodeNote" style="display:none">
              Некоторые фото не удалось декодировать (часто HEIC). Результат рассчитан частично.
            </div>
          </div>

          <div id="viewResult" class="view" hidden>
            <div class="panel">
              <!-- top row: badge + score aligned -->
              <div class="resultTop">
                <div class="badge" id="levelBadge">Результат</div>
                <div class="pill" id="scorePill">Оценка: —</div>
              </div>

              <div class="resultHead">
                <div class="resultMeta">
                  <div class="hTitle" id="levelTitle">—</div>
                  <div class="meta resultLine">
                    <span id="levelSubtitle">—</span>
                    <span id="miniExplain"></span>
                  </div>
                </div>
              </div>
            </div>

            <div class="panel">
              <div class="mono meta metaStrong" id="obsTitle">Фото-разбор</div>
              <div id="obsList"></div>
            </div>

            <div class="twoCol">
              <div class="panel">
                <div class="mono meta metaStrong" id="qcTitle">Контроль качества</div>
                <div id="flagsList"></div>
              </div>
              <div class="panel">
                <div class="mono meta metaStrong" id="complTitle">Я хочу тебе сказать, что</div>
                <div class="hSection" id="compliment"></div>
              </div>
            </div>

            <div class="panel">
              <div class="mono meta metaStrong" id="msgsTitle">Готовые сообщения продавцу (RU + 中文)</div>
              <div id="sellerMsgs" class="meta"></div>

              <div class="btnrow">
                <button class="btn" id="btnCopySeller" type="button">Скопировать продавцу</button>
                <button class="btn" id="btnShareCard" type="button">Поделиться</button>
                <button class="btn" id="btnBack" type="button">Назад</button>
              </div>

              <div class="footerNote" id="resultFooter">© rara_illustra • Анатомия товара • Для маркетплейсов</div>
            </div>
          </div>

          <div class="mobileActions" aria-label="Действия" id="mobileActions">
            <button class="btn btnPrimary flex1" id="btnPickMobile" type="button">Добавить</button>
            <button class="btn flex1" id="btnStartMobile" type="button" disabled>Начать</button>
          </div>
        </div>
      </section>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>
  <div class="srOnly" id="liveStatus" aria-live="polite"></div>

  <script>
    // =========================
    // Config
    // =========================
    const MAX_PHOTOS = 3;
    const SCAN_SECONDS = 10;
    const SCAN_DURATION_MS = 8000;

    const TEXT = {
      stageUpload: "ЭТАП: ЗАГРУЗКА",
      stageScan: "ЭТАП: СКАН",
      stageResult: "ЭТАП: РЕЗУЛЬТАТ",
      ratingSkip: "Точно нет",
      ratingMaybe: "Есть сомнения",
      ratingGreen: "Нам нравится",
      decodeNote: "Некоторые фото не удалось декодировать (часто HEIC). Результат рассчитан частично."
    };

    const COMPLIMENTS = [
      "Ты видишь то, что другие пропускают. Это и есть грамотная покупка.",
      "У тебя точный радар на качество. Прямо байер-мод.",
      "Смотри, ты сразу пошла в детали. Это о многом говорит.",
      "Ты не ведёшься на картинку, ты проверяешь.",
      "Ты умеешь отличать стиль от маркетинга. Это редкость.",
      "Подружка, ты покупаешь головой, а не эмоцией.",
      "Ты не ведёшься на картинку. Ты проверяешь, ну, моя!",
      "Замечаешь детали, которые другие пролистывают. Проверяешь, прежде чем влюбиться. Моя школа!",
      "Это не придирчивость — это навык выбирать вещи, которые выглядят хорошо не только на фото, а и в жизни, со временем, в движении.",
      "У тебя редкий дар: отличать стиль от заклинаний маркетологов.",
      "Ты не усложняешь. Ты просто знаешь, что тебе нужно.",
      "Ты выбираешь так, что потом не жалеешь.",
      "Если честно, ты уже давно выбираешь как профи",
      "Смотри, ты даже не обсуждаешь «нравится — не нравится», ты смотришь, как сделано.",
      "Смотри, ты сейчас делаешь паузу. Импульсивная покупка нам с тобой не нужна!",
      "Подружка, если что-то не откликается — это тоже ответ.",
      "Ты не обязана это брать, чтобы доказать вкус.",
      "Ты можешь пройти мимо, ничего не теряешь.",
      "Ты выбираешь так, как тебе комфортно. И за это я тебя ценю! Ну, не  только за это, конечно. ",
      "Я вижу, ты уже знаешь, чего не хочешь. Это тоже решение",
      "Ты выбираешь не из страха упустить. ",
      "Ты уже знаешь, где твоя планка и не опускаешь её, yes, giirl. ",
      "Ты выбираешь вещи, которые не надо спасать стилем. ",
      "Ты собираешь гардероб, а не впечатление. "
    ];

    const CATEGORIES = {
      universal: {
        label:"Любые товары",
        hint:"Разберём фото по делу: детали, чёткость и где может быть подвох.",
        readySubtitle:"Скан оценит риск по фото и подскажет, что запросить у продавца для верного решения.",
        scanTitle:"Скан рисков",
        steps:[
          { key:"coverage", title:"Детали", desc:"Есть ли крупные планы важных элементов." },
          { key:"clarity",  title:"Чёткость", desc:"Читаются ли мелкие детали и фактура." },
          { key:"consistency", title:"Согласованность", desc:"Похоже ли, что кадры одной вещи." },
          { key:"risk", title:"Фото-риск", desc:"Блики, пересвет, сильная обработка." },
          { key:"seller", title:"Что спросить", desc:"Собираем вопросы продавцу (RU+中文)." }
        ],
        askPool:["фото деталей крупно","фото без фильтров при дневном свете","фото изнутри/обратной стороны"],
        sellerMessages:[
          { ru:"Здравствуйте! Можете прислать фото товара крупно при дневном свете: материал/края/детали?", zh:"可以发一下... 吗？最好自然光 (材质/边缘/细节近景)。" },
          { ru:"Пожалуйста, пришлите фото изнутри/обратной стороны (если есть).", zh:"麻烦发一下内部/反面的照片（如果有的话）。" },
          { ru:"Здравствуйте! Можно фото фурнитуры крупно (молния/карабины/крепления) при дневном свете?", zh:"你好！可以发一下五金细节近景吗（拉链/扣子/卡扣/连接处）？最好自然光。" },
          { ru:"Можно фото мест крепления ручек/ремня крупно (самая нагруженная зона).", zh:"可以拍一下手柄/肩带连接处近景吗？这是最受力的位置。" },
          { ru:"Подскажите вес сумки и размеры в см (ширина/высота/глубина).", zh:"请问包的重量和实测尺寸（宽/高/厚，厘米）是多少？" },
          { ru:"Можно фото молнии вблизи: зубцы/ход молнии/есть ли маркировка.", zh:"可以拍一下拉链近景吗？拉链齿、顺滑度、是否有标识。" },
          { ru:"Покрытие фурнитуры не стирается? можно фото без пересвета, чтобы увидеть оттенок металла.", zh:"五金电镀会不会掉色？可以不过曝拍一下看真实金属颜色吗？" },
          { ru:"Есть ли запах у материала? (иногда важно понять качество обработки)", zh:"材质有没有明显气味？（想了解工艺处理情况）" },
          { ru:"Комплектация: пыльник/коробка/упаковка? можно фото комплекта.", zh:"有没有防尘袋/盒子/包装？可以拍一下配件吗？" },
          { ru:"Если есть отделения/карманы — можно фото, как они прошиты и закреплены?", zh:"如果有隔层/内袋，可以拍一下缝合和固定处近景吗？" },
          { ru:"Проверьте перед отправкой: нет ли царапин, перекоса швов, пятен.", zh:"发货前麻烦检查：是否有划痕、走线歪、污渍等。" },
          { ru:"Можно фото сумки на весу (на руке), чтобы понять, как она «держит» форму.", zh:"可以拎起来拍一下吗？挺括度和垂坠感。" }
        ]
      },

      clothing: {
        label:"Одежда",
        hint:"Ткань, швы, форма и симметрия.",
        readySubtitle:"Если нет детальной карточки ткани и швов, то есть риск купить не то.",
        scanTitle:"Скан одежды",
        steps:[
          { key:"coverage", title:"Ткань и детали", desc:"Проверяем ткань, ворот, манжеты и низ." },
          { key:"clarity",  title:"Швы", desc:"Видны ли строчки." },
          { key:"consistency", title:"Форма", desc:"Линии, карманы, посадка без перекоса." },
          { key:"risk", title:"Фото-риск", desc:"Обработка и пересветы." },
          { key:"seller", title:"Что спросить", desc:"Запросим состав (RU+中文)." }
        ],
        askPool:["фото швов крупно","фото бирки/состава","фото изнанки"],
        sellerMessages:[
          { ru:"Здравствуйте! Можно фото ткани и швов крупно при дневном свете (без фильтров)?", zh:"你好！可以发一下面料和缝线近景吗？请用自然光、不加滤镜。" },
          { ru:"Пришлите, пожалуйста, состав и фото изнанки.", zh:"麻烦发一下成分标签和反面（内侧）照片。" },
          { ru:"Можно фото манжет/низа/воротника крупно, чтобы оценить обработку?", zh:"可以发一下袖口/下摆/领口的近景吗？想确认做工细节。" },
          { ru:"Можно фото внутренней обработки швов (оверлок/подгиб)?", zh:"可以拍一下内侧走线和收边的细节吗？比如锁边/包边/折边。" },
          { ru:"Есть ли запасная пуговица/нитка? можно фото фурнитуры крупно.", zh:"有备用纽扣/备用线吗？纽扣或五金细节可以拍近景吗?" },
          { ru:"Можно короткое видео 5–10 сек без фильтров. Нужно показать ткань и посадку.", zh:"可以发一个5–10秒不加滤镜的视频吗？展示面料和版型。" },
          { ru:"Какой вес вещи? (иногда это хорошо показывает плотность ткани)", zh:"这件衣服大概多重？（重量能大致反映面料厚薄）" },
          { ru:"Материал колется/просвечивает? можно честно подсказать по ощущениям.", zh:"面料会扎/会透吗？可以如实说明一下穿着感受吗？" },
          { ru:"Можно фото при дневном свете рядом с белым листом (для точного оттенка)?", zh:"可以自然光下放一张白纸对比拍照吗？想确认色差。" }        ]
      },

      leather: {
        label:"Кожа/Замша",
        hint:"Фокус на фактуре, строчке, фурнитуре.",
        readySubtitle:"Кожа на фото часто «обманывает» бликами. Нужны крупные планы.",
        scanTitle:"Скан кожи/замши",
        steps:[
          { key:"coverage", title:"Фактура", desc:"Есть ли фильтры?" },
          { key:"clarity",  title:"Кромки/строчки", desc:"Видно ли аккуратность швов и обработку края?" },
          { key:"consistency", title:"Форма", desc:"Силуэт держится? Нет перекоса, «пузырей», заломов?" },
          { key:"risk", title:"Блики", desc:"Сильный глянец может скрывать фактуру и визуально удешевлять." },
          { key:"seller", title:"Что спросить", desc:"Запросим честные фото и короткое видео." }
        ],
        askPool:["фото фактуры крупно без бликов","фото кромок и строчек крупно","фото изнутри/подклада"],
        sellerMessages:[
          { ru:"Здравствуйте! Можно фото фактуры (зерно) крупно при дневном свете без бликов и фильтров?", zh:"你好！可以发一下皮革纹理（纹路/粒面）的近景特写吗？请用自然光、不加滤镜，尽量避免反光。" },
          { ru:"Пришлите, пожалуйста, фото кромок и строчек крупным планом (края и швы).", zh:"麻烦发一下边缘（封边/油边）和缝线的近景照片（边缘和接缝处）。" },
          { ru:"Можно фото изнутри/подкладка и фото фурнитуры (молния/кнопки) крупно?", zh:"可以发一下内里/衬里的照片，以及五金细节的近景吗？比如拉链/按扣/扣件" }
        ]
      },

      bag: {
        label:"Сумки/Аксессуары",
        hint:"Фурнитура, кант, швы, подкладка и форма.",
        readySubtitle:"Сумки чаще всего «падают» по фурнитуре и кромке.",
        scanTitle:"Скан сумок",
        steps:[
          { key:"coverage", title:"Фурнитура", desc:"Молнии, карабины и крепления." },
          { key:"clarity",  title:"Кромка/кант", desc:"Видно ли окраску и аккуратность." },
          { key:"consistency", title:"Форма", desc:"Силуэт и симметрия." },
          { key:"risk", title:"Фото-риск", desc:"Размыто, пересвет, неполные материалы." },
          { key:"seller", title:"Что спросить", desc:"Запросим подкладку и кромку (RU+中文)." }
        ],
        askPool:["фото фурнитуры крупно","фото кромки/канта","фото подкладки и швов внутри"],
        sellerMessages: [
          { ru:"Здравствуйте! Можно фото ткани и швов крупно при дневном свете (без фильтров)?", zh:"你好！可以发一下面料和缝线的近景吗？请用自然光，不加滤镜。" },
          { ru:"Пришлите, пожалуйста, фото бирки с составом и фото изнанки.", zh:"麻烦发一下成分标签的照片，以及反面（内侧）的照片。" },
          { ru:"Сделайте, пожалуйста, фото шва вблизи: строчка ровная? есть торчащие нитки?", zh:"麻烦拍一下缝线的近景：走线是否均匀？有没有线头？" },
          { ru:"Если есть принт или вышивка — можно фото крупно и с изнанки?", zh:"如果有印花/刺绣，可以拍一下近景和反面（内侧）吗？" },
          { ru:"Подскажите условия возврата и обмена, если размер не подойдёт.", zh:"如果尺码不合适，退换货规则是什么？" }

        ]
      }, 

      shoes: {
        label:"Обувь",
        hint:"Фокус на подошве, стыке, клее, форме носка и пятки, стельки.",
        readySubtitle:"Если нет фото стыка подошвы, то это плохой знак.",
        scanTitle:"Скан обуви",
        steps:[
          { key:"coverage", title:"Подошва и стык", desc:"Есть ли крупный план места соединения подошвы и верха." },
          { key:"clarity",  title:"Швы и клей", desc:"Видна ли аккуратность: нет ли излишков клея, неровных строчек, зазоров." },
          { key:"consistency", title:"Форма", desc:"Носок и пятка: симметрия пары, без перекоса и деформаций." },
          { key:"risk", title:"Фото-риск", desc:"Размыто, пересвет или мало ракурсов — по таким фото легко ошибиться." },
          { key:"seller", title:"Что спросить", desc:"Запросим крупные планы стыка и фото внутренней части обуви (RU+中文)." }
        ],
        askPool:["фото стыка подошвы крупно","фото носка и пятки крупно","фото внутри/стельки"],
        sellerMessages: [
          { ru:"Здравствуйте! Можно фото стыка подошвы и верха крупно (сбоку), при дневном свете?", zh:"你好！可以发一下鞋底与鞋面连接处的近景吗（侧面），最好自然光。" },
          { ru:"Пришлите, пожалуйста, фото носка и пятки крупно (форма/симметрия).", zh:"麻烦发一下鞋头和鞋跟近景（形状和对称性）。" },
          { ru:"Можно фото внутри: стелька и внутренняя отделка/швы?", zh:"可以发一下鞋内细节吗：鞋垫、内里做工和缝线细节。" },
          { ru:"Можно фото подошвы снизу крупно (рисунок/качество/ровность).", zh:"可以拍一下鞋底纹路近景吗？想看做工和是否平整。" },
          { ru:"Есть следы клея на стыках?", zh:"连接处有没有明显溢胶？可以不过曝实拍一下吗？" },
          { ru:"Подскажите длину стельки в см для выбранного размера (реальный замер).", zh:"请问这个尺码的鞋垫长度实测是多少厘米？" },
          { ru:"Можно фото сгиба носка (как материал ведёт себя при сгибании)?", zh:"可以拍一下鞋头弯折效果吗？看材质折痕情况。" },
          { ru:"Можно короткое видео 5–10 сек: пройтись по швам/стыку/внутри.", zh:"可以发一个5–10秒视频吗？重点拍一下接缝/连接处/鞋内。" },
          { ru:"Есть ли усиление пятки? Можно фото задника внутри.", zh:"后跟有加固吗？可以拍一下后跟内侧吗？" },
          { ru:"Съёмная стелька? Можно показать её и как сделана изнутри обувь.", zh:"鞋垫可拆吗？可以展示鞋垫以及鞋内结构吗？" },
          { ru:"Проверьте перед отправкой: нет ли перекоса пары, царапин, брака.", zh:"发货前麻烦检查：两只鞋是否对称，有无划痕/瑕疵。" },
          { ru:"Какой материал подкладки/внутри? Можно фото и описание.", zh:"内里/衬里是什么材质？可以拍照并简单说明吗？" },
          { ru:"Подскажите условия возврата/обмена, если размер не подойдёт.", zh:"如果尺码不合适，退换货规则是什么？" }
        ]
      }
    };

    // =========================
    // DOM
    // =========================
    const $ = (id)=>document.getElementById(id);

    const UI = {
      stagePill: $("stagePill"),
      phoneMode: $("phoneMode"),
      timer: $("timer"),

      categorySelect: $("categorySelect"),
      categoryHint: $("categoryHint"),
      readyBadge: $("readyBadge"),
      readySubtitle: $("readySubtitle"),
      scanTitle: $("scanTitle"),

      fileInput: $("fileInput"),
      btnPick: $("btnPick"),
      btnPickMobile: $("btnPickMobile"),
      btnDemo: $("btnDemo"),

      btnStart: $("btnStart"),
      btnStart2: $("btnStart2"),
      btnStartMobile: $("btnStartMobile"),
      btnClear: $("btnClear"),
      btnCopyLink: $("btnCopyLink"),

      btnShareCard: $("btnShareCard"),
      btnShare: $("btnShare"),
      btnBack: $("btnBack"),
      btnCopySeller: $("btnCopySeller"),

      dropZone: $("dropZone"),
      thumbs: $("thumbs"),
      heroImg: $("heroImg"),
      heroOverlay: $("heroOverlay"),

      viewReady: $("viewReady"),
      viewScan: $("viewScan"),
      viewResult: $("viewResult"),

      scanOverlay: $("scanOverlay"),
      pct: $("pct"),
      barFill: $("barFill"),
      scanTip: $("scanTip"),
      steps: $("steps"),
      decodeNote: $("decodeNote"),

      levelBadge: $("levelBadge"),
      levelTitle: $("levelTitle"),
      levelSubtitle: $("levelSubtitle"),
      miniExplain: $("miniExplain"),
      scorePill: $("scorePill"),

      obsList: $("obsList"),
      flagsList: $("flagsList"),
      compliment: $("compliment"),
      sellerMsgs: $("sellerMsgs"),

      kpiPhotos: $("kpiPhotos"),
      kpiRating: $("kpiRating"),
      kpiMarker: $("kpiMarker"),

      toast: $("toast"),
      liveStatus: $("liveStatus"),
    };

    // =========================
    // State
    // =========================
    let filesState = [];
    let previewUrls = [];
    let demoMode = false;
    let activeCategoryKey = UI.categorySelect.value || "universal";
    let runNonce = 0;        // чтобы рандом был каждый запуск
    let lastResult = null;   // будем хранить результат для карточки

    // =========================
    // Utils
    // =========================
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const fmtTime = (sec)=>`0:${String(Math.max(0,Math.floor(sec))).padStart(2,"0")}`;

    function setLive(msg){ UI.liveStatus.textContent = msg || ""; }

    function toast(msg){
      UI.toast.textContent = msg;
      UI.toast.classList.add("on");
      setLive(msg);
      clearTimeout(window.__toastTimer);
      window.__toastTimer = setTimeout(()=>UI.toast.classList.remove("on"), 1600);
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[c]));
    }

    function revokePreviews(){
      previewUrls.forEach((u)=>{ try{ URL.revokeObjectURL(u); }catch{} });
      previewUrls = [];
    }

    function isImageFile(f){
      if(!f) return false;
      if(f.type && f.type.startsWith("image/")) return true;
      const name = (f.name || "").toLowerCase();
      return /\.(jpg|jpeg|png|webp|heic|heif|gif|bmp)$/i.test(name);
    }

    function getCategory(){
      return CATEGORIES[activeCategoryKey] || CATEGORIES.universal;
    }

    function setStage(stage){
      UI.stagePill.textContent =
        stage === "scan" ? TEXT.stageScan :
        stage === "result" ? TEXT.stageResult :
        TEXT.stageUpload;
    }

    function toReady(){
      UI.phoneMode.textContent = "Готово";
      setStage("upload");
      UI.viewReady.hidden = false;
      UI.viewScan.hidden = true;
      UI.viewResult.hidden = true;
      UI.scanOverlay.classList.remove("on");
      UI.timer.textContent = "0:00";
      UI.decodeNote.style.display = "none";
      UI.decodeNote.textContent = "";
      setLive("");
    }

    function toScan(){
      UI.phoneMode.textContent = "Скан";
      setStage("scan");
      UI.viewReady.hidden = true;
      UI.viewScan.hidden = false;
      UI.viewResult.hidden = true;
      UI.scanOverlay.classList.add("on");
      UI.decodeNote.style.display = "none";
      UI.decodeNote.textContent = "";
      setLive("Сканируем…");
    }

    function toResult(){
      UI.phoneMode.textContent = "Результат";
      setStage("result");
      UI.viewReady.hidden = true;
      UI.viewScan.hidden = true;
      UI.viewResult.hidden = false;
      UI.scanOverlay.classList.remove("on");
      setLive("Результат готов");
    }

    function seedFromFiles(files, categoryKey){
      // deterministic seed (FNV-like)
      let s = 2166136261;
      const mix = (n)=>{ s ^= n; s = Math.imul(s, 16777619); s >>>= 0; };
      files.forEach((f)=>{
        const str = `${f.name}|${f.size}|${f.lastModified}`;
        for(let i=0;i<str.length;i++) mix(str.charCodeAt(i));
      });
      for(let i=0;i<categoryKey.length;i++) mix(categoryKey.charCodeAt(i));
      if(demoMode) mix(777);
      return s >>> 0;
    }

    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function randomU32(){
      try{
        if(window.crypto && crypto.getRandomValues){
          const a = new Uint32Array(1);
          crypto.getRandomValues(a);
          return a[0] >>> 0;
        }
      } catch {}
      return (Math.random() * 2**32) >>> 0;
    }
    function makeTextRng(seedBase){
      runNonce = (runNonce + 1) >>> 0;
      const timeSalt = (Date.now() & 0xffffffff) >>> 0;   // гарантирует новый поток каждый запуск
      const mixed = (seedBase ^ randomU32() ^ timeSalt ^ Math.imul(runNonce, 0x9e3779b9)) >>> 0;
      return mulberry32(mixed);
    }
    function pick(rng, arr){ return arr[Math.floor(rng() * arr.length)]; }

    function shuffleWithRng(arr, rng){
      const a = [...arr];
      for(let i=a.length-1; i>0; i--){
        const j = Math.floor(rng() * (i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    // =========================
    // Anti-repeat picks (session)
    // =========================
    const __LAST = Object.create(null);

    // pick that avoids repeating the last chosen value for the same key (within this page session)
    function pickFresh(key, arr, rng, toId = (x)=>x){
      if(!arr || arr.length === 0) return null;
      if(arr.length === 1) return arr[0];

      const lastId = __LAST[key];
      for(let i=0;i<12;i++){
        const cand = arr[Math.floor(rng() * arr.length)];
        const id = toId(cand);
        if(id !== lastId){
          __LAST[key] = id;
          return cand;
        }
      }
      const cand = arr[Math.floor(rng() * arr.length)];
      __LAST[key] = toId(cand);
      return cand;
    }

    function getPools(map, catKey){
      return map[catKey] || map.universal;
    }

    // =========================
    // UI rendering
    // =========================
    function applyCategoryUI(){
      const cat = getCategory();
      UI.categoryHint.textContent = cat.hint;
      UI.readyBadge.textContent = `Профиль: ${cat.label}`;
      UI.readySubtitle.textContent = cat.readySubtitle;
      UI.scanTitle.textContent = cat.scanTitle;

      UI.heroOverlay.textContent = filesState.length
        ? "Готово. Нажми НАЧАТЬ."
        : "Загрузи 1–3 фото и нажми НАЧАТЬ.";
    }

    function renderMobileActions(){
      const ok = filesState.length >= 1 && filesState.length <= MAX_PHOTOS;
      UI.btnStartMobile.style.display = filesState.length ? "" : "none";
      UI.btnStartMobile.disabled = !ok;
    }

    function setButtons(){
      const ok = filesState.length >= 1 && filesState.length <= MAX_PHOTOS;
      UI.btnStart.disabled = !ok;
      UI.btnStart2.disabled = !ok;
      UI.btnStartMobile.disabled = !ok;

      UI.btnClear.disabled = (filesState.length === 0 && !demoMode);
      renderMobileActions();
    }

    function updateKpi(meta = null){
      UI.kpiPhotos.textContent = String(filesState.length);

      if(filesState.length === 0){
        UI.kpiRating.textContent = "—";
        UI.kpiMarker.classList.remove("on");
        return;
      }

      let v = 0.55;
      let label = TEXT.ratingMaybe;

      if(meta && typeof meta.score === "number"){
        v = clamp(meta.score / 100, 0, 1);
        label = meta.level === "GREEN" ? TEXT.ratingGreen : meta.level === "SKIP" ? TEXT.ratingSkip : TEXT.ratingMaybe;
      } else if(meta) {
        // lightweight pre-score: coverage + clarity - glare
        const cov = meta.coverage ?? (filesState.length === 1 ? 0.38 : filesState.length === 2 ? 0.62 : 0.84);
        const cl = meta.clarity ?? 0.52;
        const glarePenalty = meta.glossy ? 0.10 : 0.0;
        v = clamp(0.50*cov + 0.50*cl - glarePenalty, 0, 1);
        label = v < 0.48 ? TEXT.ratingSkip : v < 0.78 ? TEXT.ratingMaybe : TEXT.ratingGreen;
      }

      UI.kpiRating.textContent = label;
      UI.kpiMarker.classList.add("on");
      UI.kpiMarker.style.left = `${Math.round(v * 100)}%`;
    }

    function renderThumbs(){
      revokePreviews();
      UI.thumbs.innerHTML = "";
      UI.heroImg.querySelectorAll("img").forEach(n=>n.remove());

      if(filesState.length){
        const url = URL.createObjectURL(filesState[0]);
        previewUrls.push(url);
        const img = document.createElement("img");
        img.src = url;
        img.alt = "preview";
        UI.heroImg.insertBefore(img, UI.heroImg.firstChild);
      }

      filesState.forEach((f, idx)=>{
        const url = URL.createObjectURL(f);
        previewUrls.push(url);

        const box = document.createElement("div");
        box.className = "thumb";
        box.innerHTML = `<img src="${url}" alt="preview ${idx+1}" /><div class="x" title="Удалить" aria-label="Удалить">×</div>`;

        box.querySelector(".x").addEventListener("click", (e)=>{ e.stopPropagation(); removeAt(idx); });

        UI.thumbs.appendChild(box);
      });

      applyCategoryUI();
      setButtons();
    }

    function removeAt(idx){
      filesState.splice(idx, 1);
      demoMode = false;
      renderThumbs();
      updateKpi();
      applyCategoryUI();
    }

    function addFiles(newFiles){
      demoMode = false;
      const filtered = newFiles.filter(isImageFile);

      if(filtered.length === 0){
        toast("Не вижу изображений. Добавь JPG/PNG/WEBP (HEIC зависит от браузера).");
        return;
      }

      const merged = [...filesState, ...filtered];
      if(merged.length > MAX_PHOTOS){
        toast(`Лимит ${MAX_PHOTOS} фото. Лишние не добавлены.`);
      }

      filesState = merged.slice(0, MAX_PHOTOS);
      renderThumbs();
      updateKpi();
      applyCategoryUI();
    }

    function openPicker(){ UI.fileInput.click(); }

    // =========================
    // Scan: image decode & metrics
    // =========================
    async function decodeToCanvas(file, targetW=260){
      try{
        if("createImageBitmap" in window){
          const bmp = await createImageBitmap(file).catch(()=>null);
          if(bmp){
            const w = targetW;
            const h = Math.max(120, Math.round(targetW * (bmp.height / bmp.width)));
            const c = document.createElement("canvas");
            c.width = w; c.height = Math.min(260, h);
            const ctx = c.getContext("2d", { willReadFrequently:true });
            ctx.drawImage(bmp, 0, 0, c.width, c.height);
            try{ bmp.close && bmp.close(); }catch{}
            return { canvas:c, decodeFailed:false };
          }
        }
      } catch {}

      const url = URL.createObjectURL(file);
      try{
        const img = new Image();
        img.decoding = "async";
        img.src = url;
        await new Promise((resolve, reject)=>{ img.onload = ()=>resolve(); img.onerror = ()=>reject(new Error("img load failed")); });
        const w = targetW;
        const h = Math.max(120, Math.round(targetW * (img.height / img.width)));
        const c = document.createElement("canvas");
        c.width = w; c.height = Math.min(260, h);
        const ctx = c.getContext("2d", { willReadFrequently:true });
        ctx.drawImage(img, 0, 0, c.width, c.height);
        return { canvas:c, decodeFailed:false };
      } catch {
        return { canvas:null, decodeFailed:true };
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    async function computeMetrics(file){
      const { canvas, decodeFailed } = await decodeToCanvas(file, 260);
      if(decodeFailed || !canvas){
        return { mean:140, contrast:20, highlightRatio:0.10, glossyRatio:0.10, sharpness:6, decodeFailed:true };
      }

      const ctx = canvas.getContext("2d", { willReadFrequently:true });
      const { data } = ctx.getImageData(0,0,canvas.width,canvas.height);

      let sum=0, sum2=0, n=0, hi=0, satHi=0, grad=0;
      const step = 4;

      for(let y=0;y<canvas.height;y+=step){
        for(let x=0;x<canvas.width;x+=step){
          const i = (y*canvas.width + x) * 4;
          const r = data[i], g = data[i+1], b = data[i+2];
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;

          sum += lum; sum2 += lum*lum; n++;
          if(lum > 235) hi++;

          const max = Math.max(r,g,b), min = Math.min(r,g,b);
          const sat = max === 0 ? 0 : (max-min)/max;
          if(lum > 230 && sat < 0.18) satHi++;

          if(x+step < canvas.width){
            const j = (y*canvas.width + (x+step)) * 4;
            const r2 = data[j], g2 = data[j+1], b2 = data[j+2];
            const lum2 = 0.2126*r2 + 0.7152*g2 + 0.0722*b2;
            grad += Math.abs(lum2 - lum);
          }
        }
      }

      const mean = sum / n;
      const variance = Math.max(0, (sum2/n) - mean*mean);
      const contrast = Math.sqrt(variance);
      const highlightRatio = hi / n;
      const glossyRatio = satHi / n;
      const sharpness = grad / n;

      return { mean, contrast, highlightRatio, glossyRatio, sharpness, decodeFailed:false };
    }

    function buildStepsUI(category){
      UI.steps.innerHTML = "";
      category.steps.forEach((s, idx)=>{
        const row = document.createElement("div");
        row.className = "step";
        row.innerHTML =
          `<div class="stepLeft">
            <div class="chip">${idx+1}. ${escapeHtml(s.title)}</div>
            <div class="desc">${escapeHtml(s.desc)}</div>
          </div>
          <div class="tick" id="tick-${s.key}"></div>`;
        UI.steps.appendChild(row);
      });
    }

    function setTick(key, on){
      const node = document.getElementById(`tick-${key}`);
      if(!node) return;
      node.classList.toggle("on", !!on);
    }

    function classify({ coverage, clarity, consistency, glossy, riskScore, rng }){
      // Tuned scoring: stable, but with a small deterministic "human noise"
      let score =
        60
        + (coverage - 0.55) * 40
        + (clarity  - 0.55) * 55
        + (consistency - 0.60) * 20
        - (riskScore) * 55;

      // category-specific penalties
      if(activeCategoryKey === "leather" && riskScore > 0.42) score -= 6;
      if(activeCategoryKey === "shoes" && coverage < 0.62) score -= 8;

      score += (rng() - 0.5) * 8; // small
      
      score = Math.round(clamp(score, 0, 100));

      // Если реально считаем, что есть блики/пересвет — не выдаём "ВАУ" (иначе текст будет спорить сам с собой)
      if(glossy && score >= 78) score = 77;

      let level = "MAYBE";
      if(score >= 78) level = "GREEN";
      if(score < 50) level = "SKIP";

      return { score, level };
    }

    function badgeClass(level){ return level === "GREEN" ? "good" : level === "MAYBE" ? "warn" : "bad"; }

    function levelText(level){
      if(level === "GREEN") return "ВАУ";
      if(level === "SKIP") return "НЕ СЕГОДНЯ";
      return "СОМНЕНИЯ";
    }

    function subText(level){
      if(level === "GREEN") return "Теперь нужны ценник, размер и правила доставки.";
      if(level === "SKIP") return "Доказательств мало, лучше пропустить.";
      return "Сомнительно, нужно кое-что проверить";
    }

    function ratingExplainList({ coverage, clarity, glossy, consistency }){
      const covTxt = `детализация ${coverage < 0.55 ? "1/3" : coverage < 0.75 ? "2/3" : "3/3"}`;
      const clTxt  = `чёткость ${clarity < 0.45 ? "низкая" : clarity < 0.70 ? "средняя" : "высокая"}`;
      const csTxt  = `согласованность ${consistency < 0.55 ? "отсутствует" : "есть"}`;
      const glTxt  = `блики ${glossy ? "есть" : "отсутствуют"}`;
      return [covTxt, clTxt, csTxt, glTxt];
    }

    const OBS_POOLS_BY_CAT = {
      universal: {
        coverageLow: [
          "Красиво снято и ничего не показано. Нужны детали.",
          "Видно всё… кроме того, что важно.",
          "Качество тут как призрак: все говорят, никто не видел.",
          "Покажите швы и фактуру, и я перестану подозревать.",
          "Ракурсов мало — вопросов много."
        ],
        clarityLow: [
          "Мыло мылом, а вопрос остаётся: где швы? Кромка?",
          "Пока это “мутно”. Дайте кадр в фокусе.",
          "Чёткость где-то потерялась. Пусть найдут и пришлют заново.",
          "Это фото или сон? Нужен фокус и дневной свет."
        ],
        glossyHigh: [
          "Это фото или реклама лампы? Фактура где?",
          "Фильтры старались, 5+.",
          "Окей, красиво. А теперь нормальные фото, пожалуйста.",
          "Пересвет съел детали. Очень удобно, конечно."
        ],
        consistencyLow: [
          "Есть ощущение “собрали из интернета”. Пусть подтвердят реальным кадром.",
          "На одном фото одно, на другом уже другое. Попроси совпадающий ракурс.",
          "Слишком много нестыковочек.",
          "Нужен контрольный кадр."
        ],
        good: [
          "Сейчас ок. Но я хочу видео — для душевного комфорта.",
          "Норм. Осталось понять, что там с доставкой и нервами.",
          "Выглядит как “можно”. Осталось уточнить размер и возврат.",
          "Фото норм. Теперь вопрос: доставка, возврат, размеры."
        ],
        greenExtra: [
          "Это прям кандидат на “да”.",
          "Вау-режим включился, но мы всё равно уточним условия.",
          "Не влюбляюсь… но лайк поставлю.",
          "Я искала подвох — не нашла. Непривычно."
        ],
        skipExtra: [
          "Не, я не беру на себя этот стресс. Следующий.",
          "Сейчас лучше “не сегодня”, вариантов много.",
          "БЭто выглядит как “может повезёт”. Нам такое не нужно.",
          "Не сегодня. Фото как слухи: много слов, мало фактов."
        ],
        askPrefix: [
          "Я бы попросила у продавца",
          "Следующий шаг — попроси",
          "Чтобы добить сомнения, попроси",
          "Для уверенности попроси"
        ]
      },

      clothing: {
        coverageLow: [
          "Не вижу ткани крупно и обработки низа/манжет — попроси детальные фото.",
          "Нет крупного плана швов и кромок — это главный риск по одежде.",
          "Нужны манжеты/ворот/низ крупно: там обычно видно уровень.",
          "Сейчас больше “картинка”, чем “качество” — добейся деталей.",
          "Попроси фото изнанки: по ней сразу видно класс вещи."
        ],
        clarityLow: [
          "Швы не читаются — пусть пришлют резкий кадр строчки.",
          "Нужен фокус на ткани: без резкости можно скрыть катышки/рыхлость.",
          "Пусть сфоткают у окна без фильтра — сейчас мыло.",
          "Нужен макро-кадр ткани рядом с швом."
        ],
        glossyHigh: [
          "Пересвет съедает фактуру ткани — попроси в тени, без вспышки.",
          "Свет слишком жёсткий — на нём прячутся дефекты и заломы.",
          "Блики мешают понять плотность — нужен спокойный дневной кадр.",
          "Похоже на обработку/пересвет — попроси “как есть”."
        ],
        consistencyLow: [
          "Есть ощущение разнобоя по цвету/фактуре — лучше перепроверить реальными фото.",
          "Попроси фото бирки/состава — это часто быстро выявляет “не тот лот”.",
          "Согласованность слабая — попроси видео 5–10 сек без фильтра.",
          "Могут быть разные версии модели — уточни детали и замеры."
        ],
        good: [
          "По одежде выглядит прилично. Теперь решают замеры и состав.",
          "Если посадка/размер совпадут — очень даже да.",
          "Вижу нормальную вещь, без тревоги по фото.",
          "Ок по картинке. Один контрольный кадр шва — и спокойно."
        ],
        greenExtra: [
          "Вау. Похоже на честную вещь.",
          "Зелёный по фото — дальше только замеры.",
          "Это выглядит уверенно и аккуратно.",
          "Мне нравится: без визуальных “костылей”."
        ],
        skipExtra: [
          "Без швов/ткани крупно — не сегодня.",
          "Слишком много неизвестных, а одежда этого не любит.",
          "Если продавец не даст изнанку/швы — лучше мимо.",
          "Риск “вживую не то” слишком высокий."
        ],
        askPrefix: [
          "Попроси прямо",
          "Скажи продавцу",
          "Для уверенности попроси",
          "Лучший следующий шаг — попроси"
        ]
      },

      shoes: {
        coverageLow: [
          "Нет стыка подошвы и верха крупно — по обуви это №1 красный флаг.",
          "Нужны носок/пятка/стык крупно: без этого качество не читается.",
          "Попроси фото подошвы снизу и стыка сбоку — иначе промах.",
          "Сейчас слишком общий план — по обуви так не покупают.",
          "Пусть покажут внутри (стелька/швы) — это быстро всё проясняет."
        ],
        clarityLow: [
          "Клей/швы не видно — попроси резкий кадр стыка в фокусе.",
          "Нужна чёткость по носку и пятке: там сразу видно форму.",
          "Пусть сделают фото ближе, без размытия и без компрессии.",
          "Без резкости легко скрыть зазоры и следы клея."
        ],
        glossyHigh: [
          "Пересвет мешает увидеть клей и стык — попроси без бликов.",
          "Свет “забивает” фактуру — нужен кадр у окна в тени.",
          "Блики скрывают следы клея — попроси матовый дневной снимок.",
          "Похоже на жёсткий свет — перепроверь стык и швы."
        ],
        consistencyLow: [
          "Пара может быть разная по кадрам — попроси фото обеих обуви рядом.",
          "Согласованность слабая — попроси видео по кругу 5–10 сек.",
          "Цвет/форма гуляют — лучше перепроверить реальными фото.",
          "Попроси фото маркировки/стельки — это помогает сверить модель."
        ],
        good: [
          "По фото выглядит прилично. Осталось уточнить замер стельки и возврат.",
          "Стык и форма выглядят нормально — дальше решают размер/условия.",
          "Сейчас всё спокойно. Один контрольный кадр стыка — и можно.",
          "Норм по фото. Без явных флагов."
        ],
        greenExtra: [
          "Вау-да. Выглядит аккуратно.",
          "Зелёный по фото: дальше — только замер стельки.",
          "Чисто. Держит форму, без тревоги.",
          "По фото это уверенный кандидат."
        ],
        skipExtra: [
          "Без стыка и стельки — не сегодня.",
          "Риск по обуви высокий, лучше мимо.",
          "Если продавец не покажет стык и стельку — пропускаем.",
          "Слишком много неизвестного для обуви."
        ],
        askPrefix: [
          "Следующий шаг — попроси",
          "Для уверенности — попроси",
          "Чтобы не промахнуться — попроси",
          "Попроси у продавца"
        ]
      },

      leather: {
        coverageLow: [
          "По коже без фактуры крупно нельзя: попроси зерно/срез/кромку.",
          "Нужны кромки и строчки крупно — именно там видно уровень.",
          "Попроси фото без бликов: кожа на глянце “обманывает”.",
          "Не хватает честных макро-кадров: фактура решает всё.",
          "Покажи изнанку/подклад — по нему видно качество обработки."
        ],
        clarityLow: [
          "Фактура не читается — попроси макро у окна без фильтра.",
          "Нужна резкость по кромке/строчке: сейчас слишком мягко.",
          "Пусть снимут ближе: кожа + мыло = риск.",
          "Хочу один супер-чёткий кадр зерна."
        ],
        glossyHigh: [
          "Сильные блики могут скрывать зерно и дефекты — попроси в тени.",
          "Глянец мешает понять материал — нужен матовый дневной кадр.",
          "Свет слишком жёсткий — на коже это почти всегда “маскировка”.",
          "Попроси без пересвета, чтобы увидеть реальную фактуру."
        ],
        consistencyLow: [
          "Похоже на разные условия света — попроси живые фото именно этого изделия.",
          "Согласованность слабая — попроси видео 5–10 сек без фильтра.",
          "Цвет/текстура гуляют — перепроверь реальными кадрами.",
          "Попроси фото внутри + фурнитуру: это быстро выявляет “не то”."
        ],
        good: [
          "По фото выглядит честно. Теперь решают детали и условия.",
          "Фактура читается — это уже хороший знак.",
          "Сейчас всё спокойно, без “пластикового” эффекта.",
          "Ок. Один контрольный макро-кадр — и можно."
        ],
        greenExtra: [
          "Вау. Похоже на достойный материал.",
          "Зелёный по фото: дальше только детали и условия.",
          "Выглядит уверенно и дорого в кадре.",
          "Это прям кандидат на “да”."
        ],
        skipExtra: [
          "Если продавец не даст фактуру/кромку — лучше мимо.",
          "По коже без честных макро — не рискуем.",
          "Слишком много “глянца” и тумана — пропускаем.",
          "Не сегодня: вариантов много."
        ],
        askPrefix: [
          "Попроси у продавца",
          "Лучше всего попросить",
          "Следующий шаг — попроси",
          "Чтобы не ошибиться — попроси"
        ]
      },

      bag: {
        coverageLow: [
          "По сумкам решают фурнитура и кромка — нужны крупные планы.",
          "Нет фото мест крепления ручек/ремня — это самая нагруженная зона.",
          "Попроси подклад и швы внутри: там сразу видно класс.",
          "Нужны молния/карабины крупно — без этого риск.",
          "Сейчас не хватает “технических” фото."
        ],
        clarityLow: [
          "Фурнитура и кромка не читаются — попроси резкий кадр ближе.",
          "Без чёткости не видно сколов/царапин и ровность окраса.",
          "Нужен кадр кромки в фокусе: сейчас мыло.",
          "Пусть снимут у окна без фильтра."
        ],
        glossyHigh: [
          "Пересвет по металлу скрывает качество покрытия — попроси без бликов.",
          "Свет слишком жёсткий — не видно реальный оттенок фурнитуры.",
          "Блики мешают увидеть кромку — нужен кадр в тени.",
          "Попроси “без вспышки и без фильтра”."
        ],
        consistencyLow: [
          "Есть ощущение разнобоя — попроси фото на весу и на плоскости.",
          "Согласованность слабая — попроси видео по кругу 5–10 сек.",
          "Попроси фото внутри/карманов: часто там всплывает правда.",
          "Уточни реальные размеры и вес — это быстро ловит “карточки-фейки”."
        ],
        good: [
          "По фото выглядит честно. Дальше проверяем размеры/вес/условия.",
          "Форма и детали выглядят ок — один контрольный кадр фурнитуры и можно.",
          "Сейчас всё спокойно. Дальше только условия.",
          "Ок. Без явных красных флагов."
        ],
        greenExtra: [
          "Вау. Аккуратно и уверенно выглядит.",
          "Зелёный по фото: дальше решают цена и условия.",
          "Похоже на достойную вещь.",
          "Это прям “да”, если условия ок."
        ],
        skipExtra: [
          "Без фурнитуры/кромки крупно — не сегодня.",
          "Если продавец не покажет крепления — лучше мимо.",
          "Риск по сумкам высокий без деталей — пропускаем.",
          "Вариантов много, не надо на удачу."
        ],
        askPrefix: [
          "Я бы попросила",
          "Следующий шаг — попроси",
          "Для уверенности — попроси",
          "Чтобы добить сомнения — попроси"
        ]
      }
    };

    const QC_POOLS_BY_CAT = {
      universal: {
        coverageLow: [
          { t:"Нужны детали", d:["Попроси 1–2 фото крупных планов ключевых зон.","Без деталей по фото не проверишь качество.","Добавь ракурсы: край/стык/фурнитура/внутри (что актуально)."] },
          { t:"Мало ракурсов", d:["Попроси фото со всех сторон + один макро-кадр.","Пусть покажут “самую нагруженную зону” крупно.","Попроси фото при дневном свете без фильтра."] }
        ],
        clarityLow: [
          { t:"Чёткость слабая", d:["Попроси ближе, в фокусе, без размытия.","Дневной свет у окна + без фильтра.","Пусть пришлют фото без сильного сжатия."] },
          { t:"Детали не читаются", d:["Нужен один резкий макро-кадр важной зоны.","Скажи: “без фильтров и без пересвета”.","Попроси фото 1× крупно и 1× общий план."] }
        ],
        glossyHigh: [
          { t:"Блики/пересвет", d:["Попроси кадр в тени у окна (без вспышки).","Блики скрывают фактуру — нужен матовый дневной кадр.","Попроси “как есть”, без обработки."] },
          { t:"Свет мешает оценке", d:["Попроси фото при нейтральном дневном свете.","Пусть уберут пересвет, чтобы видеть материал.","Блики = риск. Пересними без них."] }
        ],
        consistencyLow: [
          { t:"Согласованность", d:["Попроси видео 5–10 сек без фильтра.","Попроси фото именно этого лота с сегодняшней датой/листком.","Сверь детали: цвет/фурнитура/маркировки."] },
          { t:"Похоже на разные фото", d:["Попроси один набор фото в одинаковом свете.","Пусть покажут “одним дублем” по кругу.","Уточни размеры/вес — часто это вскрывает подмену."] }
        ],
        goodBase: [
          { t:"Финиш-чек", d:["Проверь условия возврата/обмена и точные замеры.","Попроси один контрольный крупный план.","Если можешь — короткое видео 5–10 сек без фильтра."] },
          { t:"Перед оплатой", d:["Уточни комплектацию и реальные размеры.","Попроси фото без фильтра при дневном свете.","Попроси показать “нагруженную зону” крупно."] }
        ],
        greenPlus: [
          { t:"Зелёный свет", d:["По фото ок. Дальше решают цена, условия и замеры.","Если продавец отвечает быстро и по делу — это плюс.","Осталась только “бытовуха”: доставка/возврат/замер."] }
        ],
        skipPlus: [
          { t:"Не сегодня", d:["Без деталей лучше пропустить.","Если продавец уклоняется — мимо.","Это слишком рискованно по фото."] }
        ],
        extras: [
          { t:"Уточнить условия", d:["Возврат/обмен? Сроки? Кто платит доставку?"] },
          { t:"Проверить размеры", d:["Попроси реальные замеры в см (не по таблице)."] },
          { t:"Попросить одно видео", d:["5–10 сек без фильтра — самый быстрый способ понять правду."] }
        ]
      },

      clothing: {
        coverageLow: [
          { t:"Ткань и обработка", d:["Нужны манжеты/низ/воротник крупно.","Попроси фото изнанки и обработки швов.","Попроси кадр ткани крупно рядом со швом."] },
          { t:"Швы обязательны", d:["Попроси макро-кадр строчки (ровность/нитки/обработка).","Попроси показать оверлок/подгиб изнутри.","Без швов одежду не покупаем."] }
        ],
        clarityLow: [
          { t:"Нужна резкость", d:["Пусть снимут ближе у окна без фильтра.","Нужен кадр шва в фокусе.","Попроси фото без сжатия/мессенджеров."] }
        ],
        glossyHigh: [
          { t:"Пересвет съедает фактуру", d:["Пусть снимут в тени у окна (без вспышки).","Проси “без фильтра” — иначе ткань не понять.","Пусть покажут ткань крупно, спокойным светом."] }
        ],
        consistencyLow: [
          { t:"Проверка лота", d:["Попроси фото бирки/состава и общий кадр вещи.","Попроси видео 5–10 сек: ткань+посадка.","Уточни замеры (грудь/длина/рукав)."] }
        ],
        goodBase: [
          { t:"Финиш-чек одежды", d:["Уточни состав, замеры и правила возврата.","Попроси один контрольный кадр шва/низа.","Если есть — короткое видео без фильтра."] }
        ],
        greenPlus: [
          { t:"Зелёный свет", d:["По фото ок. Остались состав и замеры.","Если замеры совпали — можно брать."] }
        ],
        skipPlus: [
          { t:"Не сегодня", d:["Без изнанки/швов — мимо.","Если продавец не даёт детали — пропускаем."] }
        ],
        extras: [
          { t:"Замеры", d:["Попроси реальные замеры в см (не “на глаз”)."] },
          { t:"Цвет", d:["Попроси фото при дневном свете рядом с белым листом."] },
          { t:"Видео", d:["5–10 сек без фильтра: ткань и движение."] }
        ]
      },

      shoes: {
        coverageLow: [
          { t:"Стык подошвы", d:["Попроси фото стыка подошвы и верха крупно (сбоку).","Без стыка — не покупаем.","Попроси фото подошвы снизу крупно."] },
          { t:"Внутри обуви", d:["Попроси фото стельки и внутренней отделки/швов.","Пусть покажут пятку внутри (усиление).","Попроси фото пары рядом (симметрия)."] }
        ],
        clarityLow: [
          { t:"Детали не читаются", d:["Нужен резкий кадр стыка в фокусе.","Попроси фото носка и пятки крупно.","Пусть снимут ближе без компрессии."] }
        ],
        glossyHigh: [
          { t:"Пересвет прячет клей", d:["Попроси без бликов, у окна в тени.","Пусть покажут стык без пересвета.","Блики = риск по обуви."] }
        ],
        consistencyLow: [
          { t:"Проверка пары", d:["Попроси фото обеих обуви рядом.","Попроси видео по кругу 5–10 сек.","Попроси фото маркировки/стельки."] }
        ],
        goodBase: [
          { t:"Финиш-чек обуви", d:["Уточни реальный замер стельки в см и возврат.","Попроси один контрольный кадр стыка.","Если можешь — короткое видео без фильтра."] }
        ],
        greenPlus: [
          { t:"Зелёный свет", d:["По фото ок. Остался замер стельки и условия.","Если стелька совпала — берём."] }
        ],
        skipPlus: [
          { t:"Не сегодня", d:["Без стыка/внутри — пропускаем.","Если продавец уклоняется — мимо."] }
        ],
        extras: [
          { t:"Замер стельки", d:["Попроси фото линейки на стельке (реальный замер)."] },
          { t:"Стык и клей", d:["Попроси фото без бликов, чтобы увидеть зазоры/клей."] },
          { t:"Видео", d:["5–10 сек по кругу: швы/стык/внутри."] }
        ]
      },

      leather: {
        coverageLow: [
          { t:"Фактура/зерно", d:["Попроси макро-кадр зерна при дневном свете без бликов.","Попроси фото кромки/среза крупно.","Попроси фото изнутри/подклада."] }
        ],
        clarityLow: [
          { t:"Нужна резкость", d:["Хочу один супер-чёткий кадр фактуры.","Попроси ближе, в фокусе, без фильтра.","Попроси фото кромки в фокусе."] }
        ],
        glossyHigh: [
          { t:"Блики по коже", d:["Попроси кадр в тени у окна (без вспышки).","Блики скрывают зерно — нужен матовый дневной кадр.","Попроси “как есть”, без обработки."] }
        ],
        consistencyLow: [
          { t:"Проверка изделия", d:["Попроси видео 5–10 сек без фильтра.","Попроси фото фурнитуры и внутри.","Уточни реальные размеры/вес."] }
        ],
        goodBase: [
          { t:"Финиш-чек кожи", d:["Попроси один контрольный макро-кадр зерна и кромки.","Уточни размеры/вес/возврат.","Если можешь — короткое видео без фильтра."] }
        ],
        greenPlus: [
          { t:"Зелёный свет", d:["По фото ок. Остались детали и условия.","Если продавец даёт макро без бликов — это плюс."] }
        ],
        skipPlus: [
          { t:"Не сегодня", d:["Без фактуры и кромки — пропускаем.","Если продавец не даёт макро — мимо."] }
        ],
        extras: [
          { t:"Макро фактуры", d:["Попроси зерно крупно при дневном свете."] },
          { t:"Кромка/строчка", d:["Попроси край и шов крупно — там видно класс."] },
          { t:"Видео", d:["5–10 сек без бликов и фильтра."] }
        ]
      },

      bag: {
        coverageLow: [
          { t:"Фурнитура и крепления", d:["Попроси карабины/молнии/крепления крупно.","Попроси места крепления ручек/ремня (нагруженная зона).","Попроси фото подкладки и швов внутри."] }
        ],
        clarityLow: [
          { t:"Чёткость по кромке", d:["Нужен резкий кадр кромки/канта в фокусе.","Попроси фото фурнитуры ближе.","Пусть снимут у окна без фильтра."] }
        ],
        glossyHigh: [
          { t:"Пересвет по металлу", d:["Попроси без бликов, чтобы увидеть покрытие.","Пусть покажут оттенок металла без пересвета.","Блики скрывают царапины и сколы."] }
        ],
        consistencyLow: [
          { t:"Проверка формы", d:["Попроси фото на весу и на плоскости.","Попроси видео 5–10 сек по кругу.","Уточни реальные размеры и вес."] }
        ],
        goodBase: [
          { t:"Финиш-чек сумки", d:["Уточни размеры/вес/условия возврата.","Попроси контрольный кадр фурнитуры и кромки.","Если можешь — короткое видео без фильтра."] }
        ],
        greenPlus: [
          { t:"Зелёный свет", d:["По фото ок. Остались условия и точные замеры.","Если продавец даёт крупные планы — это плюс."] }
        ],
        skipPlus: [
          { t:"Не сегодня", d:["Без фурнитуры/кромки крупно — мимо.","Если продавец уклоняется — пропускаем."] }
        ],
        extras: [
          { t:"Крепления", d:["Попроси крупно места крепления ручек/ремня."] },
          { t:"Фурнитура", d:["Попроси молнию/карабины крупно без бликов."] },
          { t:"Подклад", d:["Попроси швы и подкладку внутри."] }
        ]
      }
    };

    function buildObservations({ catKey, coverage, clarity, consistency, glossyForText, ask, level, rng }){
      const pools = getPools(OBS_POOLS_BY_CAT, catKey);
      const lines = [];
      const seen = new Set();

      const want = (level === "GREEN") ? 3 : 4;        // 3–4 варианта, как ты просила
      const beforeAsk = Math.max(2, want - 1);         // оставим место под финальную строку "что попросить"

      const add = (txt)=>{
        if(!txt) return;
        if(!seen.has(txt)){
          lines.push(txt);
          seen.add(txt);
        }
      };

      // условия
      if(coverage < 0.60 || filesState.length === 1){
        add(pickFresh(`${catKey}|obs|coverageLow`, pools.coverageLow, rng));
      }
      if(clarity < 0.45){
        add(pickFresh(`${catKey}|obs|clarityLow`, pools.clarityLow, rng));
      }
      if(glossyForText){
        add(pickFresh(`${catKey}|obs|glossyHigh`, pools.glossyHigh, rng));
      }
      if(consistency < 0.50 && filesState.length >= 2){
        add(pickFresh(`${catKey}|obs|consistencyLow`, pools.consistencyLow, rng));
      }

      // если пока пусто — позитивный блок
      if(lines.length === 0){
        add(pickFresh(`${catKey}|obs|good`, pools.good, rng));
        if(level === "GREEN") add(pickFresh(`${catKey}|obs|greenExtra`, pools.greenExtra, rng));
      } else {
        if(level === "SKIP") add(pickFresh(`${catKey}|obs|skipExtra`, pools.skipExtra, rng));
        if(level === "GREEN") add(pickFresh(`${catKey}|obs|greenExtra`, pools.greenExtra, rng));
      }

      // добиваем до нужного количества (до финального ask)
      while(lines.length < beforeAsk){
        // чередуем good/green/skip чтобы не было однообразия
        const filler =
          level === "SKIP"
            ? pickFresh(`${catKey}|obs|skipExtra`, pools.skipExtra, rng)
            : level === "GREEN"
              ? pickFresh(`${catKey}|obs|greenExtra`, pools.greenExtra, rng)
              : pickFresh(`${catKey}|obs|good`, pools.good, rng);

        add(filler);
        if(lines.length >= beforeAsk) break;

        add(pickFresh(`${catKey}|obs|good`, pools.good, rng));
      }

      // финальная строка — всегда “что попросить”
      const prefix = pickFresh(`${catKey}|obs|askPrefix`, pools.askPrefix, rng);
      add(`${prefix} ${ask}.`);

      return lines.slice(0, want);
    }

    function buildQcTips({ catKey, coverage, clarity, consistency, glossyForText, level, rng }){
      const pools = getPools(QC_POOLS_BY_CAT, catKey);
      const desired = (level === "GREEN") ? 3 : 4; // 3–4 карточки

      const tips = [];
      const used = new Set();

      const addCard = (poolKey)=>{
        const arr = pools[poolKey] || [];
        if(!arr.length) return;

        const card = pickFresh(`${catKey}|qc|${poolKey}|card`, arr, rng, (x)=>JSON.stringify(x));
        if(!card) return;

        const desc = pickFresh(`${catKey}|qc|${poolKey}|desc|${card.t}`, card.d || [], rng) || "";
        const sig = `${card.t}__${desc}`;
        if(used.has(sig)) return;

        used.add(sig);
        tips.push({ t: card.t, d: desc });
      };

      // приоритет: проблемы -> затем базовый чек
      if(coverage < 0.60 || filesState.length === 1) addCard("coverageLow");
      if(clarity < 0.45) addCard("clarityLow");
      if(glossyForText) addCard("glossyHigh");
      if(consistency < 0.50 && filesState.length >= 2) addCard("consistencyLow");

      // если ничего не сработало — базовая проверка
      if(tips.length === 0) addCard("goodBase");

      // плюсики/минусики по уровню
      if(level === "GREEN") addCard("greenPlus");
      if(level === "SKIP") addCard("skipPlus");

      // добиваем до 3–4 “extras”
      while(tips.length < desired){
        const extras = pools.extras || [];
        if(!extras.length) break;

        const card = pickFresh(`${catKey}|qc|extras|card`, extras, rng, (x)=>JSON.stringify(x));
        if(!card) break;

        const desc = pickFresh(`${catKey}|qc|extras|desc|${card.t}`, card.d || [], rng) || "";
        const sig = `${card.t}__${desc}`;
        if(used.has(sig)) continue;

        used.add(sig);
        tips.push({ t: card.t, d: desc });

        if(used.size > 40) break;
      }

      return tips.slice(0, desired);
    }

    function pickSellerMessages(category, rng){
      return shuffleWithRng(category.sellerMessages, rng).slice(0, 3);
    }

    async function sharePage(extraText=""){
      const text = extraText || "Анатомия товара — быстрый скан по фото";
      try{
        if(navigator.share) await navigator.share({ title: document.title, text, url: location.href });
        else {
          await navigator.clipboard.writeText(`${text}\n${location.href}`);
          toast("Скопировано для отправки");
        }
      } catch {
        toast("Не удалось поделиться");
      }
    }


    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function wrapLines(ctx, text, maxWidth){
      const words = String(text).split(/\s+/);
      const lines = [];
      let cur = "";
      for(const w of words){
        const test = cur ? cur + " " + w : w;
        if(ctx.measureText(test).width <= maxWidth){
          cur = test;
        } else {
          if(cur) lines.push(cur);
          cur = w;
        }
      }
      if(cur) lines.push(cur);
      return lines;
    }

    async function makeCardImage(r){
      const W = 1080, H = 1920;
      const c = document.createElement("canvas");
      c.width = W; c.height = H;
      const ctx = c.getContext("2d");

      // bg
      const g = ctx.createLinearGradient(0,0,W,H);
      g.addColorStop(0,"#f4f1ff");
      g.addColorStop(1,"#ffffff");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // main card
      const pad = 84;
      const cardX = pad, cardY = 180, cardW = W - pad*2, cardH = H - 320;
      ctx.fillStyle = "rgba(255,255,255,.98)";
      ctx.strokeStyle = "rgba(2,6,23,.10)";
      ctx.lineWidth = 4;
      roundRect(ctx, cardX, cardY, cardW, cardH, 46);
      ctx.fill();
      ctx.stroke();

      // header
      ctx.fillStyle = "rgba(15,23,42,.92)";
      ctx.font = "800 44px Inter, system-ui";
      ctx.fillText("АНАТОМИЯ ТОВАРА", cardX + 56, cardY + 110);

      ctx.fillStyle = "rgba(15,23,42,.58)";
      ctx.font = "700 24px Inter, system-ui";
      ctx.fillText("РЕЗУЛЬТАТ СКАНА", cardX + 56, cardY + 156);

      // verdict
      const verdict = r.level === "GREEN" ? "ОДОБРЕНО ✅" : r.level === "SKIP" ? "БЕЗ ШАНСОВ ❌ " : "Что-то смущает 👀";
      ctx.fillStyle = r.level === "GREEN" ? "rgba(22,163,74,.95)" : r.level === "SKIP" ? "rgba(185,28,28,.95)" : "rgba(180,83,9,.95)";
      ctx.font = "900 64px Inter, system-ui";
      ctx.fillText(verdict, cardX + 56, cardY + 260);

      // swipe line
      ctx.fillStyle = "rgba(15,23,42,.85)";
      ctx.font = "900 34px Inter, system-ui";
      const swipe = r.level === "GREEN" ? "БЕРУ ✅" : r.level === "SKIP" ? "МИМО ❌" : "УТОЧНЯЕМ ⚠️";
      ctx.fillText(swipe, cardX + 56, cardY + 318);

      // stats
      ctx.fillStyle = "rgba(15,23,42,.72)";
      ctx.font = "800 30px Inter, system-ui";
      ctx.fillText(`Оценка: ${r.score}/100`, cardX + 56, cardY + 380);

      ctx.font = "700 28px Inter, system-ui";
      ctx.fillText(`Категория: ${r.categoryLabel}`, cardX + 56, cardY + 430);

      // mini explain
      ctx.fillStyle = "rgba(15,23,42,.62)";
      ctx.font = "700 28px Inter, system-ui";
      const explainLines = wrapLines(ctx, r.miniExplain, cardW - 112);
      let y = cardY + 490;
      for(const line of explainLines.slice(0,3)){
        ctx.fillText(line, cardX + 56, y);
        y += 38;
      }

      // divider
      ctx.strokeStyle = "rgba(2,6,23,.10)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cardX + 56, y + 18);
      ctx.lineTo(cardX + cardW - 56, y + 18);
      ctx.stroke();

      y += 70;

      // observations
      ctx.fillStyle = "rgba(15,23,42,.92)";
      ctx.font = "900 34px Inter, system-ui";
      ctx.fillText("Что видно по фото:", cardX + 56, y);

      y += 52;
      ctx.fillStyle = "rgba(15,23,42,.72)";
      ctx.font = "700 30px Inter, system-ui";
      for(const item of r.obsTop){
        const bullet = "• " + item;
        const lines = wrapLines(ctx, bullet, cardW - 112);
        for(const line of lines.slice(0,3)){
          ctx.fillText(line, cardX + 56, y);
          y += 40;
        }
        y += 18;
      }

      // compliment
      y = Math.min(y + 40, cardY + cardH - 220);
      ctx.fillStyle = "rgba(124,92,255,.95)";
      ctx.font = "900 34px Inter, system-ui";
      ctx.fillText("Факт:", cardX + 56, y);

      y += 52;
      ctx.fillStyle = "rgba(15,23,42,.82)";
      ctx.font = "800 32px Inter, system-ui";
      const compLines = wrapLines(ctx, r.compliment, cardW - 112);
      for(const line of compLines.slice(0,4)){
        ctx.fillText(line, cardX + 56, y);
        y += 42;
      }

      // footer
      ctx.fillStyle = "rgba(15,23,42,.45)";
      ctx.font = "700 22px Inter, system-ui";
      ctx.fillText("Casual Anatomy Scan", cardX + 56, cardY + cardH - 56);

      const blob = await new Promise(res=>c.toBlob(res, "image/png", 1));
      return blob;
    }

    async function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 800);
    }

    async function shareOrDownloadImage(blob){
      const file = new File([blob], "casual-anatomy-card.png", { type:"image/png" });
      try{
        if(navigator.share && navigator.canShare && navigator.canShare({ files:[file] })){
          await navigator.share({ files:[file], title:"Casual Anatomy", text:"Result card" });
          return;
        }
      } catch {}
      await downloadBlob(blob, "casual-anatomy-card.png");
    }

    // =========================
    // Demo image
    // =========================
    async function makeDemoImageBlob(){
      const c = document.createElement("canvas");
      c.width = 900; c.height = 600;
      const g = c.getContext("2d");
      const grd = g.createLinearGradient(0,0,900,600);
      grd.addColorStop(0,"#f4f1ff");
      grd.addColorStop(1,"#ffffff");
      g.fillStyle = grd; g.fillRect(0,0,900,600);
      g.fillStyle = "rgba(124,92,255,.14)";
      for(let i=0;i<10;i++){
        g.beginPath();
        g.arc(120+i*72, 130+(i%2)*36, 68, 0, Math.PI*2);
        g.fill();
      }
      g.fillStyle = "#0f172a";
      g.font = "800 44px Inter, system-ui";
      g.fillText("Casual Anatomy", 60, 365);
      g.fillStyle = "rgba(15,23,42,.70)";
      g.font = "600 22px Inter, system-ui";
      g.fillText("Demo image (local scan)", 60, 410);

      return await new Promise((res)=>c.toBlob(res, "image/jpeg", 0.92));
    }

    // =========================
    // Scan flow
    // =========================
    async function runScan(){
      if(filesState.length < 1){
        toast("Добавь хотя бы 1 фото");
        return;
      }

      const category = getCategory();
      const seedBase = seedFromFiles(filesState, activeCategoryKey);
      const rngText = makeTextRng(seedBase);

      toScan();
      buildStepsUI(category);
      category.steps.forEach(s=>setTick(s.key,false));

      UI.pct.textContent = "0%";
      UI.barFill.style.width = "0%";
      UI.timer.textContent = "0:00";
      UI.scanTip.textContent = "Подготовка…";

      const metricsPromise = Promise.all(filesState.map(f=>computeMetrics(f)));
      const start = performance.now();

      const moments = [
        { t:0.18, key:"coverage", tip:"Проверяю детали…" },
        { t:0.38, key:"clarity", tip:"Оцениваю чёткость…" },
        { t:0.58, key:"consistency", tip:"Сверяю…" },
        { t:0.78, key:"risk", tip:"Ищу пересвет и фильтры…" },
        { t:0.92, key:"seller", tip:"Готовлю вопросы продавцу…" }
      ];

      const tickFrame = (now)=>{
        const p = clamp((now - start)/SCAN_DURATION_MS, 0, 1);
        const percent = Math.round(p*100);
        UI.pct.textContent = `${percent}%`;
        UI.barFill.style.width = `${percent}%`;
        UI.timer.textContent = fmtTime(Math.round(p*SCAN_SECONDS));

        for(const m of moments){
          if(p >= m.t){
            setTick(m.key, true);
            UI.scanTip.textContent = m.tip;
          }
        }

        if(p < 1) requestAnimationFrame(tickFrame);
      };
      requestAnimationFrame(tickFrame);

      await new Promise(res=>setTimeout(res, SCAN_DURATION_MS + 80));
      const metrics = await metricsPromise.catch(()=>[]);

      // Coverage by count
      const coverage = filesState.length === 1 ? 0.38 : filesState.length === 2 ? 0.62 : 0.84;

      const m = metrics.length ? metrics : [{mean:140,contrast:20,highlightRatio:0.10,glossyRatio:0.10,sharpness:6,decodeFailed:true}];

      const sharpAvg = m.reduce((a,x)=>a+x.sharpness,0)/m.length;
      const contrAvg = m.reduce((a,x)=>a+x.contrast,0)/m.length;
      const glossyAvg = m.reduce((a,x)=>a+x.glossyRatio,0)/m.length;
      const hiAvg = m.reduce((a,x)=>a+x.highlightRatio,0)/m.length;

      // clarity: sharpness + contrast
      const clarity = clamp((sharpAvg/18)*0.65 + (contrAvg/55)*0.35, 0, 1);

      // consistency: compare exposure means across photos
      const meanVals = m.map(x=>x.mean);
      const meanSpread = Math.max(...meanVals) - Math.min(...meanVals);
      const consistency = clamp(1 - (meanSpread/90), 0, 1);
      const glareStrength = hiAvg * 0.55 + glossyAvg * 0.45;
      // hiAvg < 0.32 — если "слишком белое", чаще это фон, а не блики на объекте
      const glossy = (glareStrength > 0.15 && contrAvg > 18 && hiAvg < 0.32);

      // risk score
      let risk = 0;
      if(filesState.length === 1) risk += 0.30;
      if(clarity < 0.40) risk += 0.30;
      if(glossy) risk += 0.20;
      if(consistency < 0.45 && filesState.length >= 2) risk += 0.18;
      if(m.some(x=>x.decodeFailed)) risk += 0.16;

      if(activeCategoryKey === "leather" && (glossyAvg > 0.07 || hiAvg > 0.10)) risk += 0.10;
      if(activeCategoryKey === "shoes" && coverage < 0.60) risk += 0.10;

      const riskScore = clamp(risk, 0, 1);
      // более консервативно: избегаем ложных бликов из-за белого фона/студийного света
    

      // KPI pre-result
      updateKpi({ clarity, coverage, glossy });

      const anyDecodeFail = m.some(x=>x.decodeFailed);
      if(anyDecodeFail){
        UI.decodeNote.style.display = "";
        UI.decodeNote.textContent = TEXT.decodeNote;
      }

      finishResult(category, { coverage, clarity, consistency, riskScore, glossy, rngText });    }

    function finishResult(category, ctx){
      const { coverage, clarity, consistency, riskScore, glossy, rngText } = ctx;
      const { score, level } = classify({ coverage, clarity, consistency, riskScore, glossy, rng: rngText });
      const catKey = activeCategoryKey;
      const glossyForText = (level !== "GREEN") && glossy;

    UI.levelBadge.className = `badge ${badgeClass(level)}`;
    UI.levelBadge.textContent = `РЕЗУЛЬТАТ: ${levelText(level)}`;

      // title больше не нужен (убрали повтор)
    if (UI.levelTitle) UI.levelTitle.textContent = "";

      // оставляем только нормальный поясняющий текст (не повторяем слово "сомнения")
    UI.levelSubtitle.textContent = subText(level);
    UI.scorePill.textContent = `Оценка: ${score}/100`;

    const explainList = ratingExplainList({ coverage, clarity, glossy: glossyForText, consistency });
    // одна компактная строка вместо списка
    UI.miniExplain.textContent = explainList.join(" • ");
      updateKpi({ score, level });

      const ask = pick(rngText, category.askPool);
      const obs = buildObservations({
        catKey,
        coverage, clarity, consistency,
        glossyForText,
        ask, level,
        rng: rngText
      });


      UI.obsList.innerHTML = obs.map((x)=>`
        <div class="li">
          <div class="ico"></div>
          <div><div class="liTextStrong">${escapeHtml(x)}</div></div>
        </div>
      `).join("");


      const tips = buildQcTips({
        catKey,
        coverage, clarity, consistency,
        glossyForText,
        level,
        rng: rngText
      });
      UI.flagsList.innerHTML = tips.map(x=>`
        <div class="panel panelInner">
          <div class="hSection">${escapeHtml(x.t)}</div>
          <div class="p">${escapeHtml(x.d)}</div>
        </div>
      `).join("");

      UI.compliment.textContent = pick(rngText, COMPLIMENTS);

      const msgs = pickSellerMessages(category, rngText);
      UI.sellerMsgs.innerHTML = msgs.map((m,i)=>`
        <div class="msgBlock">
          <div class="mono meta msgTitle">Сообщение ${i+1}</div>
          <div class="sp-2"></div>
          <div><b>RU:</b> ${escapeHtml(m.ru || "")}</div>
          <div class="sp-2"></div>
          <div><b>中文:</b> ${escapeHtml(m.zh || "")}</div>
        </div>
      `).join("");
      // сохраним “последний результат” для карточки
      lastResult = {
        level,
        score,
        categoryLabel: category.label,
        miniExplain: explainList.join(" • "),
        compliment: UI.compliment.textContent,
        obsTop: obs.slice(0, 4) 
      };


      UI.btnShareCard.onclick = async ()=>{
        try{
          const blob = await makeCardImage(lastResult);
          await shareOrDownloadImage(blob);
          toast("Карточка готова");
        } catch {
          toast("Не удалось сделать карточку");
        }
      };
      UI.btnCopySeller.onclick = async ()=>{
        const text = msgs.map((m,i)=>`Сообщение ${i+1}\nRU: ${m.ru||""}\n中文: ${m.zh||""}\n`).join("\n");
        try{
          await navigator.clipboard.writeText(text);
          toast("Текст продавцу скопирован");
        } catch {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try{
            document.execCommand("copy");
            toast("Текст продавцу скопирован");
          } catch {
            toast("Не удалось скопировать");
          } finally {
            ta.remove();
          }
        }
      };


      UI.btnBack.onclick = ()=>toReady();

      toResult();
    }

    // =========================
    // Events
    // =========================
    UI.btnPick.addEventListener("click", openPicker);
    UI.btnPickMobile.addEventListener("click", openPicker);
    UI.heroImg.addEventListener("click", openPicker);

    UI.fileInput.addEventListener("change", (e)=>{
      addFiles(Array.from(e.target.files || []));
      UI.fileInput.value = "";
    });

    UI.dropZone.addEventListener("dragover", (e)=>{ e.preventDefault(); });
    UI.dropZone.addEventListener("drop", (e)=>{
      e.preventDefault();
      addFiles(Array.from(e.dataTransfer?.files || []));
    });

    UI.btnClear.addEventListener("click", ()=>{
      filesState = [];
      demoMode = false;
      renderThumbs();
      updateKpi();
      toReady();
    });

    UI.btnCopyLink.addEventListener("click", async ()=>{
      const url = location.href;
      try{
        await navigator.clipboard.writeText(url);
        toast("Ссылка скопирована");
      } catch {
        const ta = document.createElement("textarea");
        ta.value = url;
        document.body.appendChild(ta);
        ta.select();
        try{
          document.execCommand("copy");
          toast("Ссылка скопирована");
        } catch {
          toast("Не получилось скопировать");
        } finally {
          ta.remove();
        }
      }
    });

    UI.btnShare.addEventListener("click", ()=>sharePage());
    // UI.btnShare2.addEventListener("click", ()=>sharePage());

    UI.btnDemo.addEventListener("click", async ()=>{
      demoMode = true;
      const blob = await makeDemoImageBlob();
      const demoFile = new File([blob], "demo-casual-anatomy.jpg", { type:"image/jpeg", lastModified: Date.now() });
      filesState = [demoFile];
      renderThumbs();
      updateKpi();
      toReady();
    });

    UI.btnStart.addEventListener("click", runScan);
    UI.btnStart2.addEventListener("click", runScan);
    UI.btnStartMobile.addEventListener("click", runScan);

    UI.categorySelect.addEventListener("change", ()=>{
      activeCategoryKey = UI.categorySelect.value;
      applyCategoryUI();
      toReady();
    });

    // =========================
    // Init
    // =========================
    function init(){
      applyCategoryUI();
      updateKpi();
      setButtons();
      toReady();
      renderThumbs();
    }

    window.addEventListener("beforeunload", ()=>revokePreviews());
    init();
  </script>
</body>
</html>
